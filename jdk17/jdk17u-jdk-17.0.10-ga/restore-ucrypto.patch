This patch restores ucrypto. It should only be applied on Solaris, as
illumos doesn't have libucrypto at all.

The module is restored verbatim. The make machinery needed to be updated
for jdk17.

diff -ur -N /tmp/a/Copy.gmk jdk15-jdk-15-24/make/modules/jdk.crypto.ucrypto/Copy.gmk
--- /tmp/a/Copy.gmk	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/make/modules/jdk.crypto.ucrypto/Copy.gmk	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,42 @@
+#
+# Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+include CopyCommon.gmk
+
+################################################################################
+
+ifeq ($(call isTargetOs, solaris), true)
+
+  UCRYPTO_CFG_SRC := $(TOPDIR)/src/jdk.crypto.ucrypto/solaris/conf/security/ucrypto-solaris.cfg
+  UCRYPTO_CFG_DST := $(CONF_DST_DIR)/security/ucrypto-solaris.cfg
+
+  $(UCRYPTO_CFG_DST): $(UCRYPTO_CFG_SRC)
+	$(call install-file)
+
+  TARGETS += $(UCRYPTO_CFG_DST)
+
+endif
+
+################################################################################
diff -ur -N /tmp/a/Lib.gmk jdk15-jdk-15-24/make/modules/jdk.crypto.ucrypto/Lib.gmk
--- /tmp/a/Lib.gmk	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/make/modules/jdk.crypto.ucrypto/Lib.gmk	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,46 @@
+#
+# Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+include LibCommon.gmk
+
+################################################################################
+
+ifeq ($(call isTargetOs, solaris), true)
+
+  $(eval $(call SetupJdkLibrary, BUILD_LIBJ2UCRYPTO, \
+      NAME := j2ucrypto, \
+      OPTIMIZATION := LOW, \
+      CFLAGS := $(CFLAGS_JDKLIB), \
+      LDFLAGS := $(LDFLAGS_JDKLIB), \
+      LIBS := $(LIBDL), \
+  ))
+
+  $(BUILD_LIBJ2UCRYPTO): $(call FindLib, java.base, java)
+
+  TARGETS += $(BUILD_LIBJ2UCRYPTO)
+
+endif
+
+################################################################################
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/CipherContextRef.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/CipherContextRef.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/CipherContextRef.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/CipherContextRef.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.nio.ByteBuffer;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+
+import java.security.*;
+import java.security.spec.*;
+import javax.crypto.*;
+
+import javax.crypto.spec.SecretKeySpec;
+import javax.crypto.spec.IvParameterSpec;
+
+/**
+ * Internal class for context resource clean up.
+ *
+ * @since 9
+ */
+final class CipherContextRef extends PhantomReference<NativeCipher>
+    implements Comparable<CipherContextRef> {
+
+    private static ReferenceQueue<NativeCipher> refQueue =
+        new ReferenceQueue<NativeCipher>();
+
+    // Needed to keep these references from being GC'ed until when their
+    // referents are GC'ed so we can do post-mortem processing
+    private static Set<CipherContextRef> refList =
+        new ConcurrentSkipListSet<CipherContextRef>();
+
+    final long id;
+    final boolean encrypt;
+
+    private static void drainRefQueueBounded() {
+        while (true) {
+            CipherContextRef next = (CipherContextRef) refQueue.poll();
+            if (next == null) break;
+            next.dispose(true);
+        }
+    }
+
+    CipherContextRef(NativeCipher nc, long id, boolean encrypt) {
+        super(nc, refQueue);
+        this.id = id;
+        this.encrypt = encrypt;
+        refList.add(this);
+        UcryptoProvider.debug("Resource: trace CipherCtxt " + this.id);
+        drainRefQueueBounded();
+    }
+
+    public int compareTo(CipherContextRef other) {
+        if (this.id == other.id) {
+            return 0;
+        } else {
+            return (this.id < other.id) ? -1 : 1;
+        }
+    }
+
+    void dispose(boolean doCancel) {
+        refList.remove(this);
+        try {
+            if (doCancel) {
+                UcryptoProvider.debug("Resource: cancel CipherCtxt " + id);
+                int k = NativeCipher.nativeFinal(id, encrypt, null, 0);
+                if (k < 0) {
+                    UcryptoProvider.debug
+                        ("Resource: error cancelling CipherCtxt " + id +
+                        " " + new UcryptoException(-k).getMessage());
+                }
+            } else {
+                UcryptoProvider.debug("Resource: untrace CipherCtxt " + id);
+            }
+        } finally {
+            this.clear();
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/Config.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/Config.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.io.*;
+import java.math.BigInteger;
+import java.util.*;
+import java.security.*;
+
+import static java.io.StreamTokenizer.*;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+
+import sun.security.action.GetPropertyAction;
+import sun.security.util.PropertyExpander;
+
+
+/**
+ * Configuration container and file parsing.
+ *
+ * Currently, there is only one supported entry "disabledServices"
+ * for disabling crypto services. Its syntax is as follows:
+ *
+ * disabledServices = {
+ * <ServiceType>.<Algorithm>
+ * ...
+ * }
+ *
+ * where <Service> can be "MessageDigest", "Cipher", etc. and <Algorithm>
+ * reprepresents the value that's passed into the various getInstance() calls.
+ *
+ * @since   9
+ */
+final class Config {
+
+    // Reader and StringTokenizer used during parsing
+    private Reader reader;
+
+    private StreamTokenizer st;
+
+    private Set<String> parsedKeywords;
+
+    // set of disabled crypto services, e.g. MessageDigest.SHA1, or
+    // Cipher.AES/ECB/PKCS5Padding
+    private Set<String> disabledServices;
+
+    Config(String filename) throws IOException {
+        FileInputStream in = new FileInputStream(expand(filename));
+        reader = new BufferedReader(new InputStreamReader(in, ISO_8859_1));
+        parsedKeywords = new HashSet<>();
+        st = new StreamTokenizer(reader);
+        setupTokenizer();
+        parse();
+    }
+
+    String[] getDisabledServices() {
+        if (disabledServices != null) {
+            return disabledServices.toArray(new String[disabledServices.size()]);
+        } else {
+            return new String[0];
+        }
+    }
+
+    private static String expand(final String s) throws IOException {
+        try {
+            return PropertyExpander.expand(s);
+        } catch (Exception e) {
+            throw new RuntimeException(e.getMessage());
+        }
+    }
+
+    private void setupTokenizer() {
+        st.resetSyntax();
+        st.wordChars('a', 'z');
+        st.wordChars('A', 'Z');
+        st.wordChars('0', '9');
+        st.wordChars(':', ':');
+        st.wordChars('.', '.');
+        st.wordChars('_', '_');
+        st.wordChars('-', '-');
+        st.wordChars('/', '/');
+        st.wordChars('\\', '\\');
+        st.wordChars('$', '$');
+        st.wordChars('{', '{'); // need {} for property subst
+        st.wordChars('}', '}');
+        st.wordChars('*', '*');
+        st.wordChars('+', '+');
+        st.wordChars('~', '~');
+        // XXX check ASCII table and add all other characters except special
+
+        // special: #="(),
+        st.whitespaceChars(0, ' ');
+        st.commentChar('#');
+        st.eolIsSignificant(true);
+        st.quoteChar('\"');
+    }
+
+    private ConfigException excToken(String msg) {
+        return new ConfigException(msg + " " + st);
+    }
+
+    private ConfigException excLine(String msg) {
+        return new ConfigException(msg + ", line " + st.lineno());
+    }
+
+    private void parse() throws IOException {
+        while (true) {
+            int token = nextToken();
+            if (token == TT_EOF) {
+                break;
+            }
+            if (token == TT_EOL) {
+                continue;
+            }
+            if (token != TT_WORD) {
+                throw excToken("Unexpected token:");
+            }
+            String word = st.sval;
+            if (word.equals("disabledServices")) {
+                parseDisabledServices(word);
+            } else {
+                throw new ConfigException
+                        ("Unknown keyword '" + word + "', line " + st.lineno());
+            }
+            parsedKeywords.add(word);
+        }
+        reader.close();
+        reader = null;
+        st = null;
+        parsedKeywords = null;
+    }
+
+    //
+    // Parsing helper methods
+    //
+    private int nextToken() throws IOException {
+        int token = st.nextToken();
+        return token;
+    }
+
+    private void parseEquals() throws IOException {
+        int token = nextToken();
+        if (token != '=') {
+            throw excToken("Expected '=', read");
+        }
+    }
+
+    private void parseOpenBraces() throws IOException {
+        while (true) {
+            int token = nextToken();
+            if (token == TT_EOL) {
+                continue;
+            }
+            if ((token == TT_WORD) && st.sval.equals("{")) {
+                return;
+            }
+            throw excToken("Expected '{', read");
+        }
+    }
+
+    private boolean isCloseBraces(int token) {
+        return (token == TT_WORD) && st.sval.equals("}");
+    }
+
+    private void checkDup(String keyword) throws IOException {
+        if (parsedKeywords.contains(keyword)) {
+            throw excLine(keyword + " must only be specified once");
+        }
+    }
+
+    private void parseDisabledServices(String keyword) throws IOException {
+        checkDup(keyword);
+        disabledServices = new HashSet<String>();
+        parseEquals();
+        parseOpenBraces();
+        while (true) {
+            int token = nextToken();
+            if (isCloseBraces(token)) {
+                break;
+            }
+            if (token == TT_EOL) {
+                continue;
+            }
+            if (token != TT_WORD) {
+                throw excToken("Expected mechanism, read");
+            }
+            disabledServices.add(st.sval);
+        }
+    }
+}
+
+class ConfigException extends IOException {
+    private static final long serialVersionUID = 254492758127673194L;
+    ConfigException(String msg) {
+        super(msg);
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/GCMParameters.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/GCMParameters.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/GCMParameters.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/GCMParameters.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.security.AlgorithmParametersSpi;
+import java.security.spec.AlgorithmParameterSpec;
+import java.security.spec.InvalidParameterSpecException;
+import javax.crypto.spec.GCMParameterSpec;
+import sun.security.util.*;
+
+/**
+ * This class implements the parameter set used with GCM mode
+ * which is defined in RFC5084 as follows:
+ *
+ * <pre>
+ * GCMParameters ::= SEQUENCE {
+ *   aes-nonce        OCTET STRING, -- recommended size is 12 octets
+ *   aes-ICVlen       AES-GCM-ICVlen DEFAULT 12 }
+ *
+ * where
+ * AES-GCM-ICVlen ::= INTEGER (12 | 13 | 14 | 15 | 16)
+ * NOTE: however, NIST 800-38D also lists 4 (32bit) and 8 (64bit)
+ * as possible AES-GCM-ICVlen values, so we allow all 6 values.
+ * </pre>
+ *
+ * @since 9
+ */
+public final class GCMParameters extends AlgorithmParametersSpi {
+
+    private byte[] iv; // i.e. aes-nonce
+    private int tLen; // i.e. aes-ICVlen, in bytes
+
+    public GCMParameters() {}
+
+    private void setValues(byte[] iv, int tLen) throws IOException {
+        if (iv == null) {
+            throw new IOException("IV cannot be null");
+        }
+        if (tLen != 4 && tLen != 8 && (tLen < 12 || tLen > 16)) {
+            throw new IOException("Unsupported tag length: " + tLen);
+        }
+        this.iv = iv;
+        this.tLen = tLen;
+    }
+
+    protected byte[] engineGetEncoded() throws IOException {
+        DerOutputStream out = new DerOutputStream();
+        DerOutputStream bytes = new DerOutputStream();
+
+        bytes.putOctetString(iv);
+        bytes.putInteger(tLen);
+        out.write(DerValue.tag_Sequence, bytes);
+        return out.toByteArray();
+    }
+
+    protected byte[] engineGetEncoded(String format) throws IOException {
+        // ignore format for now
+        return engineGetEncoded();
+    }
+
+    protected <T extends AlgorithmParameterSpec>
+            T engineGetParameterSpec(Class<T> paramSpec)
+        throws InvalidParameterSpecException {
+        if (GCMParameterSpec.class.isAssignableFrom(paramSpec)) {
+            return paramSpec.cast(new GCMParameterSpec(tLen*8, iv.clone()));
+        } else {
+            throw new InvalidParameterSpecException
+                ("Inappropriate parameter specification. Received " +
+                paramSpec.getClass().getName());
+        }
+    }
+
+    protected void engineInit(AlgorithmParameterSpec paramSpec)
+        throws InvalidParameterSpecException {
+        if (!(paramSpec instanceof GCMParameterSpec)) {
+            throw new InvalidParameterSpecException
+                ("Inappropriate parameter specification. Received " +
+                paramSpec.getClass().getName());
+        }
+        GCMParameterSpec gcmSpec = (GCMParameterSpec) paramSpec;
+        try {
+            setValues(gcmSpec.getIV(), gcmSpec.getTLen()/8);
+        } catch (IOException ioe) {
+            throw new InvalidParameterSpecException(ioe.getMessage());
+        }
+    }
+
+    protected void engineInit(byte[] encoded) throws IOException {
+        DerValue val = new DerValue(encoded);
+        if (val.tag == DerValue.tag_Sequence) {
+            val.data.reset();
+            setValues(val.data.getOctetString(), val.data.getInteger());
+        } else {
+            throw new IOException("GCM parameter parsing error: SEQ tag expected." +
+                " Received: " + val.tag);
+        }
+    }
+
+    protected void engineInit(byte[] encoded, String format)
+        throws IOException {
+        // ignore format for now
+        engineInit(encoded);
+    }
+
+    protected String engineToString() {
+        return ("IV=" + Arrays.toString(iv) + ", tLen=" + tLen * 8);
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/LibMDMech.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/LibMDMech.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/LibMDMech.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/LibMDMech.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.List;
+import static sun.security.util.SecurityProviderConstants.getAliases;
+
+/**
+ * Enum for representing the ucrypto mechanisms.
+ *
+ * @since 9
+ */
+public enum LibMDMech {
+
+    MD5(new ServiceDesc[]
+        { sd("MessageDigest", "MD5", "com.oracle.security.ucrypto.NativeDigestMD$MD5")
+        }),
+    SHA_1(new ServiceDesc[]
+        { sd("MessageDigest", "SHA-1", "com.oracle.security.ucrypto.NativeDigestMD$SHA1",
+             getAliases("SHA-1"))
+        }),
+    SHA_256(new ServiceDesc[]
+        { sd("MessageDigest", "SHA-256", "com.oracle.security.ucrypto.NativeDigestMD$SHA256",
+             getAliases("SHA-256"))
+        }),
+    SHA_384(new ServiceDesc[]
+        { sd("MessageDigest", "SHA-384", "com.oracle.security.ucrypto.NativeDigestMD$SHA384",
+             getAliases("SHA-384"))
+        }),
+    SHA_512(new ServiceDesc[]
+        { sd("MessageDigest", "SHA-512", "com.oracle.security.ucrypto.NativeDigestMD$SHA512",
+             getAliases("SHA-512"))
+        });
+
+    ServiceDesc[] serviceDescs;
+
+    private static ServiceDesc sd(String type, String algo, String cn) {
+        return new ServiceDesc(type, algo, cn, null);
+    }
+
+    private static ServiceDesc sd(String type, String algo, String cn,
+            List<String> aliases) {
+        return new ServiceDesc(type, algo, cn, aliases);
+    }
+
+    LibMDMech(ServiceDesc[] serviceDescs) {
+        this.serviceDescs = serviceDescs;
+    }
+
+    public ServiceDesc[] getServiceDescriptions() { return serviceDescs; }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeCipher.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeCipher.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeCipher.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeCipher.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,569 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.nio.ByteBuffer;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+
+import java.security.*;
+import java.security.spec.*;
+import javax.crypto.*;
+
+import javax.crypto.spec.SecretKeySpec;
+import javax.crypto.spec.IvParameterSpec;
+
+import sun.security.jca.JCAUtil;
+
+/**
+ * Cipher wrapper class utilizing ucrypto APIs. This class currently supports
+ * - AES/ECB/NOPADDING
+ * - AES/CBC/NOPADDING
+ * - AES/CTR/NOPADDING
+ * - AES/CFB128/NOPADDING
+ * (Support for GCM mode is inside the child class NativeGCMCipher)
+ *
+ * @since 9
+ */
+class NativeCipher extends CipherSpi {
+
+    // public implementation classes
+    public static final class AesEcbNoPadding extends NativeCipher {
+        public AesEcbNoPadding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_ECB);
+        }
+        public AesEcbNoPadding(int keySize) throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_ECB, keySize);
+        }
+    }
+    public static final class AesCbcNoPadding extends NativeCipher {
+        public AesCbcNoPadding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_CBC);
+        }
+        public AesCbcNoPadding(int keySize) throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_CBC, keySize);
+        }
+    }
+    public static final class AesCtrNoPadding extends NativeCipher {
+        public AesCtrNoPadding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_CTR);
+        }
+    }
+    public static final class AesCfb128NoPadding extends NativeCipher {
+        public AesCfb128NoPadding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_AES_CFB128);
+        }
+    }
+
+    // ok as constants since AES is all we support
+    public static final int AES_BLOCK_SIZE = 16;
+    public static final String AES_KEY_ALGO = "AES";
+
+    // fields set in constructor
+    protected final UcryptoMech mech;
+    protected String keyAlgo;
+    protected int blockSize;
+    protected int fixedKeySize;
+
+    //
+    // fields (re)set in every init()
+    //
+    protected CipherContextRef pCtxt = null;
+    protected byte[] keyValue = null;
+    protected byte[] iv = null;
+    protected boolean initialized = false;
+    protected boolean encrypt = true;
+    protected int bytesBuffered = 0;
+
+    // private utility methods for key re-construction
+    private static final PublicKey constructPublicKey(byte[] encodedKey,
+                                              String encodedKeyAlgorithm)
+        throws InvalidKeyException, NoSuchAlgorithmException {
+
+        PublicKey key = null;
+        try {
+            KeyFactory keyFactory =
+                KeyFactory.getInstance(encodedKeyAlgorithm);
+            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);
+            key = keyFactory.generatePublic(keySpec);
+        } catch (NoSuchAlgorithmException nsae) {
+            throw new NoSuchAlgorithmException("No provider found for " +
+                                               encodedKeyAlgorithm +
+                                               " KeyFactory");
+        } catch (InvalidKeySpecException ikse) {
+            // Should never happen
+            throw new InvalidKeyException("Cannot construct public key", ikse);
+        }
+        return key;
+    }
+
+    private static final PrivateKey constructPrivateKey(byte[] encodedKey,
+                                                String encodedKeyAlgorithm)
+        throws InvalidKeyException, NoSuchAlgorithmException {
+
+        PrivateKey key = null;
+        try {
+            KeyFactory keyFactory =
+                KeyFactory.getInstance(encodedKeyAlgorithm);
+            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);
+            key = keyFactory.generatePrivate(keySpec);
+        } catch (NoSuchAlgorithmException nsae) {
+            throw new NoSuchAlgorithmException("No provider found for " +
+                                               encodedKeyAlgorithm +
+                                               " KeyFactory");
+        } catch (InvalidKeySpecException ikse) {
+            // Should never happen
+            throw new InvalidKeyException("Cannot construct private key", ikse);
+        }
+        return key;
+    }
+
+    private static final SecretKey constructSecretKey(byte[] encodedKey,
+                                              String encodedKeyAlgorithm) {
+        return new SecretKeySpec(encodedKey, encodedKeyAlgorithm);
+    }
+
+    // package-private utility method for general key re-construction
+    static final Key constructKey(int keyType, byte[] encodedKey,
+                                  String encodedKeyAlgorithm)
+        throws InvalidKeyException, NoSuchAlgorithmException {
+        Key result = null;
+        switch (keyType) {
+        case Cipher.SECRET_KEY:
+            result = constructSecretKey(encodedKey,
+                                        encodedKeyAlgorithm);
+            break;
+        case Cipher.PRIVATE_KEY:
+            result = constructPrivateKey(encodedKey,
+                                         encodedKeyAlgorithm);
+            break;
+        case Cipher.PUBLIC_KEY:
+            result = constructPublicKey(encodedKey,
+                                        encodedKeyAlgorithm);
+            break;
+        }
+        return result;
+    }
+
+    NativeCipher(UcryptoMech mech, int fixedKeySize) throws NoSuchAlgorithmException {
+        this.mech = mech;
+        // defaults to AES - the only supported symmetric cipher algo
+        this.blockSize = AES_BLOCK_SIZE;
+        this.keyAlgo = AES_KEY_ALGO;
+        this.fixedKeySize = fixedKeySize;
+    }
+
+    NativeCipher(UcryptoMech mech) throws NoSuchAlgorithmException {
+        this(mech, -1);
+    }
+
+    @Override
+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
+        // Disallow change of mode for now since currently it's explicitly
+        // defined in transformation strings
+        throw new NoSuchAlgorithmException("Unsupported mode " + mode);
+    }
+
+    // see JCE spec
+    @Override
+    protected void engineSetPadding(String padding)
+            throws NoSuchPaddingException {
+        // Disallow change of padding for now since currently it's explicitly
+        // defined in transformation strings
+        throw new NoSuchPaddingException("Unsupported padding " + padding);
+    }
+
+    // see JCE spec
+    @Override
+    protected int engineGetBlockSize() {
+        return blockSize;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineGetOutputSize(int inputLen) {
+        return getOutputSizeByOperation(inputLen, true);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineGetIV() {
+        return (iv != null? iv.clone() : null);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized AlgorithmParameters engineGetParameters() {
+        AlgorithmParameters params = null;
+        try {
+            if (iv != null) {
+                IvParameterSpec ivSpec = new IvParameterSpec(iv.clone());
+                params = AlgorithmParameters.getInstance(keyAlgo);
+                params.init(ivSpec);
+            }
+        } catch (GeneralSecurityException e) {
+            // NoSuchAlgorithmException, NoSuchProviderException
+            // InvalidParameterSpecException
+            throw new UcryptoException("Could not encode parameters", e);
+        }
+        return params;
+    }
+
+    @Override
+    protected int engineGetKeySize(Key key) throws InvalidKeyException {
+        return checkKey(key) * 8;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key,
+            SecureRandom random) throws InvalidKeyException {
+        try {
+            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);
+        } catch (InvalidAlgorithmParameterException e) {
+            throw new InvalidKeyException("init() failed", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key,
+            AlgorithmParameterSpec params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        checkKey(key);
+        if (opmode != Cipher.ENCRYPT_MODE &&
+            opmode != Cipher.DECRYPT_MODE &&
+            opmode != Cipher.WRAP_MODE &&
+            opmode != Cipher.UNWRAP_MODE) {
+            throw new InvalidAlgorithmParameterException
+                ("Unsupported mode: " + opmode);
+        }
+        boolean doEncrypt =
+                (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE);
+
+        byte[] ivBytes = null;
+        if (mech == UcryptoMech.CRYPTO_AES_ECB) {
+            if (params != null) {
+                throw new InvalidAlgorithmParameterException
+                        ("No Parameters for ECB mode");
+            }
+        } else {
+            if (params != null) {
+                if (!(params instanceof IvParameterSpec)) {
+                    throw new InvalidAlgorithmParameterException
+                            ("IvParameterSpec required. Received: " +
+                            params.getClass().getName());
+                } else {
+                    ivBytes = ((IvParameterSpec) params).getIV();
+                    if (ivBytes.length != blockSize) {
+                        throw new InvalidAlgorithmParameterException
+                             ("Wrong IV length: must be " + blockSize +
+                              " bytes long. Received length:" + ivBytes.length);
+                    }
+                }
+            } else {
+                if (encrypt) {
+                    // generate IV if none supplied for encryption
+                    ivBytes = new byte[blockSize];
+                    if (random == null) {
+                        random = JCAUtil.getSecureRandom();
+                    }
+                    random.nextBytes(ivBytes);
+                } else {
+                    throw new InvalidAlgorithmParameterException
+                            ("Parameters required for decryption");
+                }
+            }
+        }
+        init(doEncrypt, key.getEncoded().clone(), ivBytes);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key,
+            AlgorithmParameters params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        AlgorithmParameterSpec spec = null;
+        if (params != null) {
+            try {
+                spec = params.getParameterSpec(IvParameterSpec.class);
+            } catch (InvalidParameterSpecException iaps) {
+                throw new InvalidAlgorithmParameterException(iaps);
+            }
+        }
+        engineInit(opmode, key, spec, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineUpdate(byte[] in, int ofs, int len) {
+        byte[] out = new byte[getOutputSizeByOperation(len, false)];
+        int n = update(in, ofs, len, out, 0);
+        if (n == 0) {
+            return null;
+        } else if (out.length != n) {
+            out = Arrays.copyOf(out, n);
+        }
+        return out;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineUpdate(byte[] in, int inOfs, int inLen,
+        byte[] out, int outOfs) throws ShortBufferException {
+        int min = getOutputSizeByOperation(inLen, false);
+        if (out.length - outOfs < min) {
+            throw new ShortBufferException("min " + min + "-byte buffer needed");
+        }
+        return update(in, inOfs, inLen, out, outOfs);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineUpdateAAD(byte[] src, int ofs, int len)
+            throws IllegalStateException {
+        throw new IllegalStateException("No AAD can be supplied");
+    }
+
+    // see JCE spec
+    @Override
+    protected void engineUpdateAAD(ByteBuffer src)
+            throws IllegalStateException {
+        throw new IllegalStateException("No AAD can be supplied");
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineDoFinal(byte[] in, int ofs, int len)
+            throws IllegalBlockSizeException, BadPaddingException {
+        byte[] out = new byte[getOutputSizeByOperation(len, true)];
+        try {
+            // delegate to the other engineDoFinal(...) method
+            int k = engineDoFinal(in, ofs, len, out, 0);
+            if (out.length != k) {
+                out = Arrays.copyOf(out, k);
+            }
+            return out;
+        } catch (ShortBufferException e) {
+            throw new UcryptoException("Internal Error", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineDoFinal(byte[] in, int inOfs, int inLen,
+                                             byte[] out, int outOfs)
+            throws ShortBufferException, IllegalBlockSizeException,
+            BadPaddingException {
+        int k = 0;
+        int min = getOutputSizeByOperation(inLen, true);
+        if (out.length - outOfs < min) {
+            throw new ShortBufferException("min " + min + "-byte buffer needed");
+        }
+        if (inLen > 0) {
+            k = update(in, inOfs, inLen, out, outOfs);
+            outOfs += k;
+        }
+        k += doFinal(out, outOfs);
+        return k;
+    }
+
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineWrap(Key key)
+            throws IllegalBlockSizeException, InvalidKeyException {
+        byte[] result = null;
+        try {
+            byte[] encodedKey = key.getEncoded();
+            if ((encodedKey == null) || (encodedKey.length == 0)) {
+                throw new InvalidKeyException("Cannot get an encoding of " +
+                                              "the key to be wrapped");
+            }
+            result = engineDoFinal(encodedKey, 0, encodedKey.length);
+        } catch (BadPaddingException e) {
+            // Should never happen for key wrapping
+            throw new UcryptoException("Internal Error" , e);
+        }
+        return result;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized Key engineUnwrap(byte[] wrappedKey,
+            String wrappedKeyAlgorithm, int wrappedKeyType)
+            throws InvalidKeyException, NoSuchAlgorithmException {
+
+        byte[] encodedKey;
+        Key result = null;
+        try {
+            encodedKey = engineDoFinal(wrappedKey, 0,
+                                       wrappedKey.length);
+        } catch (Exception e) {
+            throw (InvalidKeyException)
+                (new InvalidKeyException()).initCause(e);
+        }
+
+        return constructKey(wrappedKeyType, encodedKey, wrappedKeyAlgorithm);
+    }
+
+    final int checkKey(Key key) throws InvalidKeyException {
+        if (key == null || key.getEncoded() == null) {
+            throw new InvalidKeyException("Key cannot be null");
+        } else {
+            // check key algorithm and format
+            if (!keyAlgo.equalsIgnoreCase(key.getAlgorithm())) {
+                throw new InvalidKeyException("Key algorithm must be " +
+                    keyAlgo);
+            }
+            if (!"RAW".equalsIgnoreCase(key.getFormat())) {
+                throw new InvalidKeyException("Key format must be RAW");
+            }
+            int keyLen = key.getEncoded().length;
+            if (fixedKeySize == -1) {
+                // all 3 AES key lengths are allowed
+                if (keyLen != 16 && keyLen != 24 && keyLen != 32) {
+                    throw new InvalidKeyException("Key size is not valid." +
+                        " Got key length of: " + keyLen);
+                }
+            } else {
+                if (keyLen != fixedKeySize) {
+                    throw new InvalidKeyException("Only " + fixedKeySize +
+                        "-byte keys are accepted. Got: " + keyLen);
+                }
+            }
+            // return the validated key length in bytes
+            return keyLen;
+        }
+    }
+
+    protected void reset(boolean doCancel) {
+        initialized = false;
+        bytesBuffered = 0;
+        if (pCtxt != null) {
+            pCtxt.dispose(doCancel);
+            pCtxt = null;
+        }
+    }
+
+    /**
+     * calls ucrypto_encrypt_init(...) or ucrypto_decrypt_init(...)
+     * @return pointer to the context
+     */
+    protected native static long nativeInit(int mech, boolean encrypt,
+                                            byte[] key, byte[] iv,
+                                            int tagLen, byte[] aad);
+
+    /**
+     * calls ucrypto_encrypt_update(...) or ucrypto_decrypt_update(...)
+     * @return the length of output or if negative, an error status code
+     */
+    private native static int nativeUpdate(long pContext, boolean encrypt,
+                                           byte[] in, int inOfs, int inLen,
+                                           byte[] out, int outOfs);
+
+    /**
+     * calls ucrypto_encrypt_final(...) or ucrypto_decrypt_final(...)
+     * @return the length of output or if negative, an error status code
+     */
+    native static int nativeFinal(long pContext, boolean encrypt,
+                                          byte[] out, int outOfs);
+
+    protected void ensureInitialized() {
+        if (!initialized) {
+            init(encrypt, keyValue, iv);
+            if (!initialized) {
+                throw new UcryptoException("Cannot initialize Cipher");
+            }
+        }
+    }
+
+    protected int getOutputSizeByOperation(int inLen, boolean isDoFinal) {
+        if (inLen <= 0) {
+            inLen = 0;
+        }
+        if (!isDoFinal && (inLen == 0)) {
+            return 0;
+        }
+        return inLen + bytesBuffered;
+    }
+
+    // actual init() implementation - caller should clone key and iv if needed
+    protected void init(boolean encrypt, byte[] keyVal, byte[] ivVal) {
+        reset(true);
+        this.encrypt = encrypt;
+        this.keyValue = keyVal;
+        this.iv = ivVal;
+        long pCtxtVal = nativeInit(mech.value(), encrypt, keyValue, iv, 0, null);
+        initialized = (pCtxtVal != 0L);
+        if (initialized) {
+            pCtxt = new CipherContextRef(this, pCtxtVal, encrypt);
+        } else {
+            throw new UcryptoException("Cannot initialize Cipher");
+        }
+    }
+
+    // Caller MUST check and ensure output buffer has enough capacity
+    private int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {
+        ensureInitialized();
+        if (inLen <= 0) { return 0; }
+
+        int k = nativeUpdate(pCtxt.id, encrypt, in, inOfs, inLen, out, outOfs);
+        if (k < 0) {
+            reset(false);
+            // cannot throw ShortBufferException here since it's too late
+            // native context is invalid upon any failure
+            throw new UcryptoException(-k);
+        }
+        bytesBuffered += (inLen - k);
+        return k;
+    }
+
+    // Caller MUST check and ensure output buffer has enough capacity
+    private int doFinal(byte[] out, int outOfs) throws IllegalBlockSizeException,
+            BadPaddingException {
+        try {
+            ensureInitialized();
+
+            int k = nativeFinal(pCtxt.id, encrypt, out, outOfs);
+            if (k < 0) {
+                String cause = UcryptoException.getErrorMessage(-k);
+                if (cause.endsWith("_LEN_RANGE")) {
+                    throw new IllegalBlockSizeException(cause);
+                } else if (cause.endsWith("_DATA_INVALID")) {
+                    throw new BadPaddingException(cause);
+                } else {
+                    throw new UcryptoException(-k);
+                }
+            }
+            return k;
+        } finally {
+            reset(false);
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeCipherWithJavaPadding.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeCipherWithJavaPadding.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeCipherWithJavaPadding.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeCipherWithJavaPadding.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,468 @@
+/*
+ * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.nio.ByteBuffer;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+
+import java.security.AlgorithmParameters;
+import java.security.GeneralSecurityException;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.Key;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+
+
+import java.security.spec.AlgorithmParameterSpec;
+import java.security.spec.InvalidParameterSpecException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.CipherSpi;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+
+import javax.crypto.spec.IvParameterSpec;
+
+/**
+ * Wrapper class which uses NativeCipher class and Java impls of padding scheme.
+ * This class currently supports
+ * - AES/ECB/PKCS5PADDING
+ * - AES/CBC/PKCS5PADDING
+ * - AES/CFB128/PKCS5PADDING
+ *
+ * @since 9
+ */
+public class NativeCipherWithJavaPadding extends CipherSpi {
+
+    private static interface Padding {
+        // ENC: generate and return the necessary padding bytes
+        int getPadLen(int dataLen);
+
+        // ENC: generate and return the necessary padding bytes
+        byte[] getPaddingBytes(int dataLen);
+
+        // DEC: process the decrypted data and buffer up the potential padding
+        // bytes
+        byte[] bufferBytes(byte[] intermediateData);
+
+        // DEC: return the length of internally buffered pad bytes
+        int getBufferedLength();
+
+        // DEC: unpad and place the output in 'out', starting from outOfs
+        // and return the number of bytes unpadded into 'out'.
+        int unpad(byte[] paddedData, byte[] out, int outOfs)
+                throws BadPaddingException, IllegalBlockSizeException,
+                ShortBufferException;
+
+        // DEC: Clears the padding object to the initial state
+        void clear();
+    }
+
+    private static class PKCS5Padding implements Padding {
+        private final int blockSize;
+        // buffer for storing the potential padding bytes
+        private ByteBuffer trailingBytes = null;
+
+        PKCS5Padding(int blockSize)
+            throws NoSuchPaddingException {
+            if (blockSize == 0) {
+                throw new NoSuchPaddingException
+                        ("PKCS#5 padding not supported with stream ciphers");
+            }
+            this.blockSize = blockSize;
+        }
+
+        public int getPadLen(int dataLen) {
+            return (blockSize - (dataLen & (blockSize - 1)));
+        }
+
+        public byte[] getPaddingBytes(int dataLen) {
+            byte padValue = (byte) getPadLen(dataLen);
+            byte[] paddingBytes = new byte[padValue];
+            Arrays.fill(paddingBytes, padValue);
+            return paddingBytes;
+        }
+
+        public byte[] bufferBytes(byte[] dataFromUpdate) {
+            if (dataFromUpdate == null || dataFromUpdate.length == 0) {
+                return null;
+            }
+            byte[] result = null;
+            if (trailingBytes == null) {
+                trailingBytes = ByteBuffer.wrap(new byte[blockSize]);
+            }
+            int tbSize = trailingBytes.position();
+            if (dataFromUpdate.length > trailingBytes.remaining()) {
+                int totalLen = dataFromUpdate.length + tbSize;
+                int newTBSize = totalLen % blockSize;
+                if (newTBSize == 0) {
+                    newTBSize = blockSize;
+                }
+                if (tbSize == 0) {
+                    result = Arrays.copyOf(dataFromUpdate, totalLen - newTBSize);
+                } else {
+                    // combine 'trailingBytes' and 'dataFromUpdate'
+                    result = Arrays.copyOf(trailingBytes.array(),
+                                           totalLen - newTBSize);
+                    if (result.length != tbSize) {
+                        System.arraycopy(dataFromUpdate, 0, result, tbSize,
+                                         result.length - tbSize);
+                    }
+                }
+                // update 'trailingBytes' w/ remaining bytes in 'dataFromUpdate'
+                trailingBytes.clear();
+                trailingBytes.put(dataFromUpdate,
+                                  dataFromUpdate.length - newTBSize, newTBSize);
+            } else {
+                trailingBytes.put(dataFromUpdate);
+            }
+            return result;
+        }
+
+        public int getBufferedLength() {
+            if (trailingBytes != null) {
+                return trailingBytes.position();
+            }
+            return 0;
+        }
+
+        public int unpad(byte[] lastData, byte[] out, int outOfs)
+                throws BadPaddingException, IllegalBlockSizeException,
+                ShortBufferException {
+            int tbSize = (trailingBytes == null? 0:trailingBytes.position());
+            int dataLen = tbSize + lastData.length;
+
+            // Special handling to match SunJCE provider behavior
+            if (dataLen <= 0) {
+                return 0;
+            } else if (dataLen % blockSize != 0) {
+                UcryptoProvider.debug("PKCS5Padding: unpad, buffered " + tbSize +
+                                 " bytes, last block " + lastData.length + " bytes");
+
+                throw new IllegalBlockSizeException
+                    ("Input length must be multiples of " + blockSize);
+            }
+
+            // check padding bytes
+            if (lastData.length == 0) {
+                if (tbSize != 0) {
+                    // work on 'trailingBytes' directly
+                    lastData = Arrays.copyOf(trailingBytes.array(), tbSize);
+                    trailingBytes.clear();
+                    tbSize = 0;
+                } else {
+                    throw new BadPaddingException("No pad bytes found!");
+                }
+            }
+            byte padValue = lastData[lastData.length - 1];
+            if (padValue < 1 || padValue > blockSize) {
+                UcryptoProvider.debug("PKCS5Padding: unpad, lastData: " + Arrays.toString(lastData));
+                UcryptoProvider.debug("PKCS5Padding: unpad, padValue=" + padValue);
+                throw new BadPaddingException("Invalid pad value: " + padValue);
+            }
+
+            // sanity check padding bytes
+            int padStartIndex = lastData.length - padValue;
+            for (int i = padStartIndex; i < lastData.length; i++) {
+                if (lastData[i] != padValue) {
+                    UcryptoProvider.debug("PKCS5Padding: unpad, lastData: " + Arrays.toString(lastData));
+                    UcryptoProvider.debug("PKCS5Padding: unpad, padValue=" + padValue);
+                    throw new BadPaddingException("Invalid padding bytes!");
+                }
+            }
+
+            int actualOutLen = dataLen - padValue;
+            // check output buffer capacity
+            if (out.length - outOfs < actualOutLen) {
+                throw new ShortBufferException("Output buffer too small, need " + actualOutLen +
+                    ", got " + (out.length - outOfs));
+            }
+            try {
+                if (tbSize != 0) {
+                    trailingBytes.rewind();
+                    if (tbSize < actualOutLen) {
+                        trailingBytes.get(out, outOfs, tbSize);
+                        outOfs += tbSize;
+                    } else {
+                        // copy from trailingBytes and we are done
+                        trailingBytes.get(out, outOfs, actualOutLen);
+                        return actualOutLen;
+                    }
+                }
+                if (lastData.length > padValue) {
+                    System.arraycopy(lastData, 0, out, outOfs,
+                                     lastData.length - padValue);
+                }
+                return actualOutLen;
+            } finally {
+                clear();
+            }
+        }
+
+        public void clear() {
+            if (trailingBytes != null) trailingBytes.clear();
+        }
+    }
+
+    public static final class AesEcbPKCS5 extends NativeCipherWithJavaPadding {
+        public AesEcbPKCS5() throws NoSuchAlgorithmException, NoSuchPaddingException {
+            super(new NativeCipher.AesEcbNoPadding(), "PKCS5Padding");
+        }
+    }
+
+    public static final class AesCbcPKCS5 extends NativeCipherWithJavaPadding {
+        public AesCbcPKCS5() throws NoSuchAlgorithmException, NoSuchPaddingException {
+            super(new NativeCipher.AesCbcNoPadding(), "PKCS5Padding");
+        }
+    }
+
+    public static final class AesCfb128PKCS5 extends NativeCipherWithJavaPadding {
+        public AesCfb128PKCS5() throws NoSuchAlgorithmException, NoSuchPaddingException {
+            super(new NativeCipher.AesCfb128NoPadding(), "PKCS5Padding");
+        }
+    }
+
+    // fields (re)set in every init()
+    private final NativeCipher nc;
+    private final Padding padding;
+    private final int blockSize;
+    private int lastBlockLen = 0;
+
+    // Only ECB, CBC, CTR, and CFB128 modes w/ NOPADDING for now
+    NativeCipherWithJavaPadding(NativeCipher nc, String paddingScheme)
+        throws NoSuchAlgorithmException, NoSuchPaddingException {
+        this.nc = nc;
+        this.blockSize = nc.engineGetBlockSize();
+        if (paddingScheme.toUpperCase(Locale.ROOT).equals("PKCS5PADDING")) {
+            padding = new PKCS5Padding(blockSize);
+        } else {
+            throw new NoSuchAlgorithmException("Unsupported padding scheme: " + paddingScheme);
+        }
+    }
+
+    void reset() {
+        padding.clear();
+        lastBlockLen = 0;
+    }
+
+    @Override
+    protected synchronized void engineSetMode(String mode) throws NoSuchAlgorithmException {
+        nc.engineSetMode(mode);
+    }
+
+    // see JCE spec
+    @Override
+    protected void engineSetPadding(String padding)
+            throws NoSuchPaddingException {
+        // Disallow change of padding for now since currently it's explicitly
+        // defined in transformation strings
+        throw new NoSuchPaddingException("Unsupported padding " + padding);
+    }
+
+    // see JCE spec
+    @Override
+    protected int engineGetBlockSize() {
+        return blockSize;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineGetOutputSize(int inputLen) {
+        int result = nc.engineGetOutputSize(inputLen);
+        if (nc.encrypt) {
+            result += padding.getPadLen(result);
+        } else {
+            result += padding.getBufferedLength();
+        }
+        return result;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineGetIV() {
+        return nc.engineGetIV();
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized AlgorithmParameters engineGetParameters() {
+        return nc.engineGetParameters();
+    }
+
+    @Override
+    protected int engineGetKeySize(Key key) throws InvalidKeyException {
+        return nc.engineGetKeySize(key);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key, SecureRandom random)
+            throws InvalidKeyException {
+        reset();
+        nc.engineInit(opmode, key, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key,
+            AlgorithmParameterSpec params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        reset();
+        nc.engineInit(opmode, key, params, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key, AlgorithmParameters params,
+            SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        reset();
+        nc.engineInit(opmode, key, params, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
+        if (nc.encrypt) {
+            lastBlockLen += inLen;
+            lastBlockLen &= (blockSize - 1);
+            return nc.engineUpdate(in, inOfs, inLen);
+        } else {
+            return padding.bufferBytes(nc.engineUpdate(in, inOfs, inLen));
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,
+            int outOfs) throws ShortBufferException {
+        if (nc.encrypt) {
+            lastBlockLen += inLen;
+            lastBlockLen &= (blockSize - 1);
+            return nc.engineUpdate(in, inOfs, inLen, out, outOfs);
+        } else {
+            byte[] result = padding.bufferBytes(nc.engineUpdate(in, inOfs, inLen));
+            if (result != null) {
+                System.arraycopy(result, 0, out, outOfs, result.length);
+                return result.length;
+            } else return 0;
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
+            throws IllegalBlockSizeException, BadPaddingException {
+        int estimatedOutLen = engineGetOutputSize(inLen);
+        byte[] out = new byte[estimatedOutLen];
+        try {
+            int actualOut = this.engineDoFinal(in, inOfs, inLen, out, 0);
+            // truncate off extra bytes
+            if (actualOut != out.length) {
+                out = Arrays.copyOf(out, actualOut);
+            }
+        } catch (ShortBufferException sbe) {
+            throw new UcryptoException("Internal Error", sbe);
+        } finally {
+            reset();
+        }
+        return out;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,
+                                             int outOfs)
+        throws ShortBufferException, IllegalBlockSizeException,
+               BadPaddingException {
+        int estimatedOutLen = engineGetOutputSize(inLen);
+        if (out.length - outOfs < estimatedOutLen) {
+            throw new ShortBufferException("Actual: " + (out.length - outOfs) +
+                ". Estimated Out Length: " + estimatedOutLen);
+        }
+        try {
+            if (nc.encrypt) {
+                int k = nc.engineUpdate(in, inOfs, inLen, out, outOfs);
+                lastBlockLen += inLen;
+                lastBlockLen &= (blockSize - 1);
+                byte[] padBytes = padding.getPaddingBytes(lastBlockLen);
+                k += nc.engineDoFinal(padBytes, 0, padBytes.length, out, (outOfs + k));
+                return k;
+            } else {
+                byte[] tempOut = nc.engineDoFinal(in, inOfs, inLen);
+                int len = padding.unpad(tempOut, out, outOfs);
+                return len;
+            }
+        } finally {
+            reset();
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineWrap(Key key) throws IllegalBlockSizeException,
+                                                InvalidKeyException {
+        byte[] result = null;
+        try {
+            byte[] encodedKey = key.getEncoded();
+            if ((encodedKey == null) || (encodedKey.length == 0)) {
+                throw new InvalidKeyException("Cannot get an encoding of " +
+                                              "the key to be wrapped");
+            }
+            result = engineDoFinal(encodedKey, 0, encodedKey.length);
+        } catch (BadPaddingException e) {
+            // Should never happen for key wrapping
+            throw new UcryptoException("Internal Error", e);
+        }
+        return result;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,
+                               int wrappedKeyType)
+        throws InvalidKeyException, NoSuchAlgorithmException {
+
+        byte[] encodedKey;
+        try {
+            encodedKey = engineDoFinal(wrappedKey, 0,
+                                       wrappedKey.length);
+        } catch (Exception e) {
+            throw (InvalidKeyException)
+                (new InvalidKeyException()).initCause(e);
+        }
+
+        return NativeCipher.constructKey(wrappedKeyType, encodedKey,
+                                         wrappedKeyAlgorithm);
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeDigest.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeDigest.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeDigest.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeDigest.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.lang.ref.*;
+
+import java.io.ByteArrayOutputStream;
+import java.util.*;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.security.*;
+
+/**
+ * MessageDigest implementation class using native Ucrypto API.
+ * This class currently supports: MD5, SHA-2 (224, 256, 384, 512)
+ * and SHA-3 (224, 256, 384, 512) digests
+ *
+ * @since 9
+ */
+abstract class NativeDigest extends MessageDigestSpi {
+
+    public static final class MD5 extends NativeDigest {
+        public MD5() {
+            super(UcryptoMech.CRYPTO_MD5, 16);
+        }
+    }
+    public static final class SHA1 extends NativeDigest {
+        public SHA1() {
+            super(UcryptoMech.CRYPTO_SHA1, 20);
+        }
+    }
+    public static final class SHA224 extends NativeDigest {
+        public SHA224() {
+            super(UcryptoMech.CRYPTO_SHA224, 28);
+        }
+    }
+    public static final class SHA256 extends NativeDigest {
+        public SHA256() {
+            super(UcryptoMech.CRYPTO_SHA256, 32);
+        }
+    }
+    public static final class SHA384 extends NativeDigest {
+        public SHA384() {
+            super(UcryptoMech.CRYPTO_SHA384, 48);
+        }
+    }
+    public static final class SHA512 extends NativeDigest {
+        public SHA512() {
+            super(UcryptoMech.CRYPTO_SHA512, 64);
+        }
+    }
+    public static final class SHA3_224 extends NativeDigest {
+        public SHA3_224() {
+            super(UcryptoMech.CRYPTO_SHA3_224, 28);
+        }
+    }
+    public static final class SHA3_256 extends NativeDigest {
+        public SHA3_256() {
+            super(UcryptoMech.CRYPTO_SHA3_256, 32);
+        }
+    }
+    public static final class SHA3_384 extends NativeDigest {
+        public SHA3_384() {
+            super(UcryptoMech.CRYPTO_SHA3_384, 48);
+        }
+    }
+    public static final class SHA3_512 extends NativeDigest {
+        public SHA3_512() {
+            super(UcryptoMech.CRYPTO_SHA3_512, 64);
+        }
+    }
+
+    private final int digestLen;
+    private final UcryptoMech mech;
+
+    // field for ensuring native memory is freed
+    private DigestContextRef pCtxt = null;
+
+    private static class DigestContextRef extends PhantomReference<NativeDigest>
+        implements Comparable<DigestContextRef> {
+
+        private static ReferenceQueue<NativeDigest> refQueue =
+            new ReferenceQueue<NativeDigest>();
+
+        // Needed to keep these references from being GC'ed until when their
+        // referents are GC'ed so we can do post-mortem processing
+        private static Set<DigestContextRef> refList =
+            new ConcurrentSkipListSet<DigestContextRef>();
+
+        private final long id;
+        private final UcryptoMech mech;
+
+        private static void drainRefQueueBounded() {
+            while (true) {
+                DigestContextRef next = (DigestContextRef) refQueue.poll();
+                if (next == null) break;
+                next.dispose(true);
+            }
+        }
+
+        DigestContextRef(NativeDigest nc, long id, UcryptoMech mech) {
+            super(nc, refQueue);
+            this.id = id;
+            this.mech = mech;
+            refList.add(this);
+            UcryptoProvider.debug("Resource: track Digest Ctxt " + this.id);
+            drainRefQueueBounded();
+        }
+
+        public int compareTo(DigestContextRef other) {
+            if (this.id == other.id) {
+                return 0;
+            } else {
+                return (this.id < other.id) ? -1 : 1;
+            }
+        }
+
+        void dispose(boolean needFree) {
+            refList.remove(this);
+            try {
+                if (needFree) {
+                    UcryptoProvider.debug("Resource: free Digest Ctxt " +
+                        this.id);
+                    NativeDigest.nativeFree(mech.value(), id);
+                } else {
+                    UcryptoProvider.debug("Resource: discard Digest Ctxt " +
+                        this.id);
+                }
+            } finally {
+                this.clear();
+            }
+        }
+    }
+
+    NativeDigest(UcryptoMech mech, int digestLen) {
+        this.mech = mech;
+        this.digestLen = digestLen;
+    }
+
+    // see JCA spec
+    protected int engineGetDigestLength() {
+        return digestLen;
+    }
+
+    // see JCA spec
+    protected synchronized void engineReset() {
+        if (pCtxt != null) {
+            pCtxt.dispose(true);
+            pCtxt = null;
+        }
+    }
+
+    // see JCA spec
+    protected synchronized byte[] engineDigest() {
+        byte[] digest = new byte[digestLen];
+        try {
+            int len = engineDigest(digest, 0, digestLen);
+            if (len != digestLen) {
+                throw new UcryptoException("Digest length mismatch." +
+                    " Len: " + len + ". digestLen: " + digestLen);
+            }
+            return digest;
+        } catch (DigestException de) {
+            throw new UcryptoException("Internal error", de);
+        }
+    }
+
+    // see JCA spec
+    protected synchronized int engineDigest(byte[] out, int ofs, int len)
+            throws DigestException {
+        if (len < digestLen) {
+            throw new DigestException("Output buffer must be at least " +
+                          digestLen + " bytes long. Got: " + len);
+        }
+        if ((ofs < 0) || (len < 0) || (ofs > out.length - len)) {
+            throw new DigestException("Buffer too short to store digest. " +
+                "ofs: " + ofs + ". len: " + len + ". out.length: " + out.length);
+        }
+
+        if (pCtxt == null) {
+            pCtxt = new DigestContextRef(this, nativeInit(mech.value()), mech);
+        }
+        try {
+            int status = nativeDigest(mech.value(), pCtxt.id, out, ofs, digestLen);
+            if (status != 0) {
+                throw new DigestException("Internal error: " + status);
+            }
+        } finally {
+            pCtxt.dispose(false);
+            pCtxt = null;
+        }
+        return digestLen;
+    }
+
+    // see JCA spec
+    protected synchronized void engineUpdate(byte in) {
+        byte[] temp = { in };
+        engineUpdate(temp, 0, 1);
+    }
+
+    // see JCA spec
+    protected synchronized void engineUpdate(byte[] in, int ofs, int len) {
+        if (len == 0) {
+            return;
+        }
+        if ((ofs < 0) || (len < 0) || (ofs > in.length - len)) {
+            throw new ArrayIndexOutOfBoundsException("ofs: " + ofs + ". len: "
+                + len + ". in.length: " + in.length);
+        }
+        if (pCtxt == null) {
+            pCtxt = new DigestContextRef(this, nativeInit(mech.value()), mech);
+        }
+        nativeUpdate(mech.value(), pCtxt.id, in, ofs, len);
+    }
+
+    /**
+     * Clone this digest.
+     */
+    public synchronized Object clone() throws CloneNotSupportedException {
+        throw new CloneNotSupportedException("Clone is not supported");
+    }
+
+    // return pointer to the context
+    protected static final native long nativeInit(int mech);
+    // return status code; always 0
+    protected static final native int nativeUpdate(int mech, long pCtxt, byte[] in, int ofs, int inLen);
+    // return status code; always 0
+    protected static final native int nativeDigest(int mech, long pCtxt, byte[] out, int ofs, int digestLen);
+    // free the specified context
+    private static final native void nativeFree(int mech, long id);
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeDigestMD.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeDigestMD.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeDigestMD.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeDigestMD.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.lang.ref.*;
+
+import java.io.ByteArrayOutputStream;
+import java.util.*;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.security.*;
+
+/**
+ * MessageDigest implementation class for libMD API. This class currently supports
+ * MD5, SHA1, SHA256, SHA384, and SHA512
+ *
+ * @since 9
+ */
+public abstract class NativeDigestMD extends MessageDigestSpi
+        implements Cloneable {
+
+    private static final int MECH_MD5 = 1;
+    private static final int MECH_SHA1 = 2;
+    private static final int MECH_SHA256 = 3;
+    private static final int MECH_SHA224 = 4;
+    private static final int MECH_SHA384 = 5;
+    private static final int MECH_SHA512 = 6;
+
+    private final int digestLen;
+    private final int mech;
+
+    // field for ensuring native memory is freed
+    private DigestContextRef pCtxt = null;
+
+    private static class DigestContextRef extends PhantomReference<NativeDigestMD>
+        implements Comparable<DigestContextRef> {
+
+        private static ReferenceQueue<NativeDigestMD> refQueue =
+            new ReferenceQueue<NativeDigestMD>();
+
+        // Needed to keep these references from being GC'ed until when their
+        // referents are GC'ed so we can do post-mortem processing
+        private static Set<DigestContextRef> refList =
+            new ConcurrentSkipListSet<DigestContextRef>();
+            //            Collections.synchronizedSortedSet(new TreeSet<DigestContextRef>());
+
+        private final long id;
+        private final int mech;
+
+        private static void drainRefQueueBounded() {
+            while (true) {
+                DigestContextRef next = (DigestContextRef) refQueue.poll();
+                if (next == null) break;
+                next.dispose(true);
+            }
+        }
+
+        DigestContextRef(NativeDigestMD nc, long id, int mech) {
+            super(nc, refQueue);
+            this.id = id;
+            this.mech = mech;
+            refList.add(this);
+            UcryptoProvider.debug("Resource: track Digest Ctxt " + this.id);
+            drainRefQueueBounded();
+        }
+
+        public int compareTo(DigestContextRef other) {
+            if (this.id == other.id) {
+                return 0;
+            } else {
+                return (this.id < other.id) ? -1 : 1;
+            }
+        }
+
+        void dispose(boolean needFree) {
+            refList.remove(this);
+            try {
+                if (needFree) {
+                    UcryptoProvider.debug("Resource: free Digest Ctxt " + this.id);
+                    NativeDigestMD.nativeFree(mech, id);
+                } else UcryptoProvider.debug("Resource: stop tracking Digest Ctxt " + this.id);
+            } finally {
+                this.clear();
+            }
+        }
+    }
+
+    NativeDigestMD(int mech, int digestLen) {
+        this.digestLen = digestLen;
+        this.mech = mech;
+    }
+
+    // see JCA spec
+    protected int engineGetDigestLength() {
+        return digestLen;
+    }
+
+    // see JCA spec
+    protected synchronized void engineReset() {
+        if (pCtxt != null) {
+            pCtxt.dispose(true);
+            pCtxt = null;
+        }
+    }
+
+    // see JCA spec
+    protected synchronized byte[] engineDigest() {
+        byte[] digest = new byte[digestLen];
+        try {
+            int len = engineDigest(digest, 0, digestLen);
+            if (len != digestLen) {
+                throw new UcryptoException("Digest length mismatch." +
+                    " Len: " + len + ". digestLen: " + digestLen);
+            }
+            return digest;
+        } catch (DigestException de) {
+            throw new UcryptoException("Internal error", de);
+        }
+    }
+
+    // see JCA spec
+    protected synchronized int engineDigest(byte[] out, int ofs, int len)
+            throws DigestException {
+        if (len < digestLen) {
+            throw new DigestException("Output buffer must be at least " +
+                          digestLen + " bytes long. Got: " + len);
+        }
+        if ((ofs < 0) || (len < 0) || (ofs > out.length - len)) {
+            throw new DigestException("Buffer too short to store digest. " +
+                "ofs: " + ofs + ". len: " + len + ". out.length: " + out.length);
+        }
+
+        if (pCtxt == null) {
+            pCtxt = new DigestContextRef(this, nativeInit(mech), mech);
+        }
+        try {
+            int status = nativeDigest(mech, pCtxt.id, out, ofs, digestLen);
+            if (status != 0) {
+                throw new DigestException("Internal error: " + status);
+            }
+        } finally {
+            pCtxt.dispose(false);
+            pCtxt = null;
+        }
+        return digestLen;
+    }
+
+    // see JCA spec
+    protected synchronized void engineUpdate(byte in) {
+        byte[] temp = { in };
+        engineUpdate(temp, 0, 1);
+    }
+
+    // see JCA spec
+    protected synchronized void engineUpdate(byte[] in, int ofs, int len) {
+        if (len == 0) {
+            return;
+        }
+        if ((ofs < 0) || (len < 0) || (ofs > in.length - len)) {
+            throw new ArrayIndexOutOfBoundsException("ofs: " + ofs + ". len: "
+                + len + ". in.length: " + in.length);
+        }
+        if (pCtxt == null) {
+            pCtxt = new DigestContextRef(this, nativeInit(mech), mech);
+        }
+        nativeUpdate(mech, pCtxt.id, in, ofs, len);
+    }
+
+    /**
+     * Clone this digest.
+     */
+    public synchronized Object clone() throws CloneNotSupportedException {
+        NativeDigestMD copy = (NativeDigestMD) super.clone();
+        // re-work the fields that cannot be copied over
+        if (pCtxt != null) {
+            copy.pCtxt = new DigestContextRef(this, nativeClone(mech, pCtxt.id), mech);
+        }
+        return copy;
+    }
+
+    // return pointer to the context
+    protected static final native long nativeInit(int mech);
+    // return status code; always 0
+    protected static final native int nativeUpdate(int mech, long pCtxt, byte[] in, int ofs, int inLen);
+    // return status code; always 0
+    protected static final native int nativeDigest(int mech, long pCtxt, byte[] out, int ofs, int digestLen);
+    // return pointer to the duplicated context
+    protected static final native long nativeClone(int mech, long pCtxt);
+    // free the specified context
+    private static final native void nativeFree(int mech, long id);
+
+
+    public static final class MD5 extends NativeDigestMD {
+        public MD5() {
+            super(MECH_MD5, 16);
+        }
+    }
+
+    public static final class SHA1 extends NativeDigestMD {
+        public SHA1() {
+            super(MECH_SHA1, 20);
+        }
+    }
+
+    public static final class SHA256 extends NativeDigestMD {
+        public SHA256() {
+            super(MECH_SHA256, 32);
+        }
+    }
+
+
+    public static final class SHA384 extends NativeDigestMD {
+        public SHA384() {
+            super(MECH_SHA384, 48);
+        }
+    }
+
+
+    public static final class SHA512 extends NativeDigestMD {
+        public SHA512() {
+            super(MECH_SHA512, 64);
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeGCMCipher.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeGCMCipher.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeGCMCipher.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeGCMCipher.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,458 @@
+/*
+ * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
+
+import java.util.Set;
+import java.util.Arrays;
+import java.security.*;
+import java.security.spec.*;
+import javax.crypto.*;
+import javax.crypto.spec.SecretKeySpec;
+import javax.crypto.spec.GCMParameterSpec;
+
+import sun.security.jca.JCAUtil;
+
+/**
+ * Cipher wrapper class utilizing ucrypto APIs. This class currently supports
+ * - AES/GCM/NoPADDING
+ *
+ * @since 9
+ */
+class NativeGCMCipher extends NativeCipher {
+
+    public static final class AesGcmNoPadding extends NativeGCMCipher {
+        public AesGcmNoPadding() throws NoSuchAlgorithmException {
+            super(-1);
+        }
+        public AesGcmNoPadding(int keySize) throws NoSuchAlgorithmException {
+            super(keySize);
+        }
+    }
+
+    private static final int DEFAULT_TAG_LEN = 128; // same as SunJCE provider
+
+    // same as SunJCE provider, see GaloisCounterMode.java for details
+    private static final int MAX_BUF_SIZE = Integer.MAX_VALUE;
+
+    // buffer for storing AAD data; if null, meaning buffer content has been
+    // supplied to native context
+    private ByteArrayOutputStream aadBuffer;
+
+    // buffer for storing input in decryption, not used for encryption
+    private ByteArrayOutputStream ibuffer;
+
+    // needed for checking against MAX_BUF_SIZE
+    private int processed;
+
+    private int tagLen = DEFAULT_TAG_LEN;
+
+    /*
+     * variables used for performing the GCM (key+iv) uniqueness check.
+     * To use GCM mode safely, the cipher object must be re-initialized
+     * with a different combination of key + iv values for each
+     * ENCRYPTION operation. However, checking all past key + iv values
+     * isn't feasible. Thus, we only do a per-instance check of the
+     * key + iv values used in previous encryption.
+     * For decryption operations, no checking is necessary.
+     */
+    private boolean requireReinit;
+    private byte[] lastEncKey = null;
+    private byte[] lastEncIv = null;
+
+    private void checkAndUpdateProcessed(int len) {
+        // Currently, cipher text and tag are packed in one byte array, so
+        // the impl-specific limit for input data size is (MAX_BUF_SIZE - tagLen)
+        int inputDataLimit = MAX_BUF_SIZE - tagLen;
+
+        if (processed > inputDataLimit - len) {
+            throw new ProviderException("OracleUcrypto provider only supports " +
+                "input size up to " + inputDataLimit + " bytes");
+        }
+        processed += len;
+    }
+
+    NativeGCMCipher(int fixedKeySize) throws NoSuchAlgorithmException {
+        super(UcryptoMech.CRYPTO_AES_GCM, fixedKeySize);
+    }
+
+    @Override
+    protected void ensureInitialized() {
+        if (!initialized) {
+            byte[] aad = null;
+            if (aadBuffer != null) {
+                if (aadBuffer.size() > 0) {
+                    aad = aadBuffer.toByteArray();
+                }
+            }
+            init(encrypt, keyValue, iv, tagLen, aad);
+            aadBuffer = null;
+            if (!initialized) {
+                throw new UcryptoException("Cannot initialize Cipher");
+            }
+        }
+    }
+
+    @Override
+    protected int getOutputSizeByOperation(int inLen, boolean isDoFinal) {
+        if (inLen < 0) return 0;
+
+        if (!isDoFinal && (inLen == 0)) {
+            return 0;
+        }
+
+        int result = inLen + bytesBuffered;
+        if (encrypt) {
+            if (isDoFinal) {
+                result += tagLen/8;
+            }
+        } else {
+            if (ibuffer != null) {
+                result += ibuffer.size();
+            }
+            result -= tagLen/8;
+        }
+        if (result < 0) {
+            result = 0;
+        }
+        return result;
+    }
+
+    @Override
+    protected void reset(boolean doCancel) {
+        super.reset(doCancel);
+        if (aadBuffer == null) {
+            aadBuffer = new ByteArrayOutputStream();
+        } else {
+            aadBuffer.reset();
+        }
+
+        if (ibuffer != null) {
+            ibuffer.reset();
+        }
+        if (!encrypt) requireReinit = false;
+        processed = 0;
+    }
+
+    // actual init() implementation - caller should clone key and iv if needed
+    protected void init(boolean encrypt, byte[] keyVal, byte[] ivVal, int tLen, byte[] aad) {
+        reset(true);
+        this.encrypt = encrypt;
+        this.keyValue = keyVal;
+        this.iv = ivVal;
+        long pCtxtVal = NativeCipher.nativeInit(mech.value(), encrypt, keyValue, iv,
+            tLen, aad);
+        initialized = (pCtxtVal != 0L);
+        if (initialized) {
+            pCtxt = new CipherContextRef(this, pCtxtVal, encrypt);
+        } else {
+            throw new UcryptoException("Cannot initialize Cipher");
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized AlgorithmParameters engineGetParameters() {
+        AlgorithmParameters params = null;
+        try {
+            if (iv != null) {
+                GCMParameterSpec gcmSpec = new GCMParameterSpec(tagLen, iv.clone());
+                params = AlgorithmParameters.getInstance("GCM");
+                params.init(gcmSpec);
+            }
+        } catch (GeneralSecurityException e) {
+            // NoSuchAlgorithmException, NoSuchProviderException
+            // InvalidParameterSpecException
+            throw new UcryptoException("Could not encode parameters", e);
+        }
+        return params;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key,
+            AlgorithmParameterSpec params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        checkKey(key);
+        if (opmode != Cipher.ENCRYPT_MODE &&
+            opmode != Cipher.DECRYPT_MODE &&
+            opmode != Cipher.WRAP_MODE &&
+            opmode != Cipher.UNWRAP_MODE) {
+            throw new InvalidAlgorithmParameterException
+                ("Unsupported mode: " + opmode);
+        }
+        aadBuffer = new ByteArrayOutputStream();
+        boolean doEncrypt = (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE);
+        byte[] keyBytes = key.getEncoded().clone();
+        byte[] ivBytes = null;
+        if (params != null) {
+            if (!(params instanceof GCMParameterSpec)) {
+                throw new InvalidAlgorithmParameterException("GCMParameterSpec required." +
+                    " Received: " + params.getClass().getName());
+            } else {
+                tagLen = ((GCMParameterSpec) params).getTLen();
+                ivBytes = ((GCMParameterSpec) params).getIV();
+            }
+        } else {
+            if (doEncrypt) {
+                tagLen = DEFAULT_TAG_LEN;
+
+                // generate IV if none supplied for encryption
+                ivBytes = new byte[blockSize];
+                if (random == null) {
+                    random = JCAUtil.getSecureRandom();
+                }
+                random.nextBytes(ivBytes);
+            } else {
+                throw new InvalidAlgorithmParameterException("Parameters required for decryption");
+            }
+        }
+        if (doEncrypt) {
+            requireReinit = Arrays.equals(ivBytes, lastEncIv) &&
+                MessageDigest.isEqual(keyBytes, lastEncKey);
+            if (requireReinit) {
+                throw new InvalidAlgorithmParameterException
+                    ("Cannot reuse iv for GCM encryption");
+            }
+            lastEncIv = ivBytes;
+            lastEncKey = keyBytes;
+            ibuffer = null;
+        } else {
+            requireReinit = false;
+            ibuffer = new ByteArrayOutputStream();
+        }
+        try {
+            init(doEncrypt, keyBytes, ivBytes, tagLen, null);
+        } catch (UcryptoException ex) {
+            if (ex.getError() ==
+                UcryptoException.Error.CRYPTO_MECHANISM_PARAM_INVALID) {
+
+                throw new InvalidAlgorithmParameterException(ex.getMessage());
+            } else {
+                throw ex;
+            }
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key, AlgorithmParameters params,
+            SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        AlgorithmParameterSpec spec = null;
+        if (params != null) {
+            try {
+                // mech must be UcryptoMech.CRYPTO_AES_GCM
+                spec = params.getParameterSpec(GCMParameterSpec.class);
+            } catch (InvalidParameterSpecException iaps) {
+                throw new InvalidAlgorithmParameterException(iaps);
+            }
+        }
+        engineInit(opmode, key, spec, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
+        if (aadBuffer != null) {
+            if (aadBuffer.size() > 0) {
+                // init again with AAD data
+                init(encrypt, keyValue, iv, tagLen, aadBuffer.toByteArray());
+            }
+            aadBuffer = null;
+        }
+        if (requireReinit) {
+            throw new IllegalStateException
+                ("Must use either different key or iv for GCM encryption");
+        }
+        checkAndUpdateProcessed(inLen);
+        if (inLen > 0) {
+            if (!encrypt) {
+                ibuffer.write(in, inOfs, inLen);
+                return null;
+            }
+            return super.engineUpdate(in, inOfs, inLen);
+        } else return null;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,
+            int outOfs) throws ShortBufferException {
+        int len = getOutputSizeByOperation(inLen, false);
+        if (out.length - outOfs < len) {
+            throw new ShortBufferException("Output buffer must be " +
+                 "(at least) " + len + " bytes long. Got: " +
+                 (out.length - outOfs));
+        }
+        if (aadBuffer != null) {
+            if (aadBuffer.size() > 0) {
+                // init again with AAD data
+                init(encrypt, keyValue, iv, tagLen, aadBuffer.toByteArray());
+            }
+            aadBuffer = null;
+        }
+        if (requireReinit) {
+            throw new IllegalStateException
+                ("Must use either different key or iv for GCM encryption");
+        }
+        checkAndUpdateProcessed(inLen);
+        if (inLen > 0) {
+            if (!encrypt) {
+                ibuffer.write(in, inOfs, inLen);
+                return 0;
+            } else {
+                return super.engineUpdate(in, inOfs, inLen, out, outOfs);
+            }
+        }
+        return 0;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineUpdateAAD(byte[] src, int srcOfs, int srcLen)
+            throws IllegalStateException {
+
+        if ((src == null) || (srcOfs < 0) || (srcOfs + srcLen > src.length)) {
+            throw new IllegalArgumentException("Invalid AAD");
+        }
+        if (keyValue == null) {
+            throw new IllegalStateException("Need to initialize Cipher first");
+        }
+        if (requireReinit) {
+            throw new IllegalStateException
+                ("Must use either different key or iv for GCM encryption");
+        }
+        if (aadBuffer != null) {
+            aadBuffer.write(src, srcOfs, srcLen);
+        } else {
+            // update has already been called
+            throw new IllegalStateException
+                ("Update has been called; no more AAD data");
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected void engineUpdateAAD(ByteBuffer src)
+            throws IllegalStateException {
+        if (src == null) {
+            throw new IllegalArgumentException("Invalid AAD");
+        }
+        if (keyValue == null) {
+            throw new IllegalStateException("Need to initialize Cipher first");
+        }
+        if (requireReinit) {
+            throw new IllegalStateException
+                ("Must use either different key or iv for GCM encryption");
+        }
+        if (aadBuffer != null) {
+            if (src.hasRemaining()) {
+                byte[] srcBytes = new byte[src.remaining()];
+                src.get(srcBytes);
+                aadBuffer.write(srcBytes, 0, srcBytes.length);
+            }
+        } else {
+            // update has already been called
+            throw new IllegalStateException
+                ("Update has been called; no more AAD data");
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
+            throws IllegalBlockSizeException, BadPaddingException {
+        byte[] out = new byte[getOutputSizeByOperation(inLen, true)];
+        try {
+            // delegate to the other engineDoFinal(...) method
+            int k = engineDoFinal(in, inOfs, inLen, out, 0);
+            if (out.length != k) {
+                out = Arrays.copyOf(out, k);
+            }
+            return out;
+        } catch (ShortBufferException e) {
+            throw new UcryptoException("Internal Error", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineDoFinal(byte[] in, int inOfs, int inLen,
+                                             byte[] out, int outOfs)
+        throws ShortBufferException, IllegalBlockSizeException,
+               BadPaddingException {
+        int len = getOutputSizeByOperation(inLen, true);
+        if (out.length - outOfs < len) {
+            throw new ShortBufferException("Output buffer must be "
+                + "(at least) " + len + " bytes long. Got: " +
+                (out.length - outOfs));
+        }
+        if (aadBuffer != null) {
+            if (aadBuffer.size() > 0) {
+                // init again with AAD data
+                init(encrypt, keyValue, iv, tagLen, aadBuffer.toByteArray());
+            }
+            aadBuffer = null;
+        }
+        if (requireReinit) {
+            throw new IllegalStateException
+                ("Must use either different key or iv for GCM encryption");
+        }
+
+        checkAndUpdateProcessed(inLen);
+        if (!encrypt) {
+            if (inLen > 0) {
+                ibuffer.write(in, inOfs, inLen);
+            }
+            inLen = ibuffer.size();
+            if (inLen < tagLen/8) {
+                // Otherwise, Solaris lib will error out w/ CRYPTO_BUFFER_TOO_SMALL
+                // when ucrypto_decrypt_final() is called
+                throw new AEADBadTagException("Input too short - need tag." +
+                    " inLen: " + inLen + ". tagLen: " + tagLen);
+            }
+            // refresh 'in' to all buffered-up bytes
+            in = ibuffer.toByteArray();
+            inOfs = 0;
+            ibuffer.reset();
+        }
+        try {
+            return super.engineDoFinal(in, inOfs, inLen, out, outOfs);
+        } catch (UcryptoException ue) {
+            if (ue.getMessage().equals("CRYPTO_INVALID_MAC")) {
+                throw new AEADBadTagException("Tag does not match");
+            } else {
+                // pass it up
+                throw ue;
+            }
+        } finally {
+            requireReinit = encrypt;
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeKey.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeKey.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeKey.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeKey.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.Set;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+
+import java.math.BigInteger;
+import java.security.*;
+import java.security.interfaces.*;
+import java.security.spec.*;
+
+/**
+ * Wrapper class for native keys needed for using ucrypto APIs.
+ * This class currently supports native RSA private/public keys.
+ *
+ * @since 9
+ */
+abstract class NativeKey implements Key {
+
+    private static final long serialVersionUID = 6812507588904302830L;
+
+    private final int numComponents;
+
+    NativeKey(int numComponents) {
+        this.numComponents = numComponents;
+    }
+
+    abstract long value();
+
+    int length() {
+        return numComponents;
+    }
+
+    public String getAlgorithm() { return "RSA"; }
+    public String getFormat() { return "RAW"; }
+    public byte[] getEncoded() {
+        // not used; so not generated
+        return null;
+    }
+
+    private native static void nativeFree(long id, int numComponents);
+
+    static byte[] getMagnitude(BigInteger bi) {
+        byte[] b = bi.toByteArray();
+        if ((b.length > 1) && (b[0] == 0)) {
+            int n = b.length - 1;
+            byte[] newarray = new byte[n];
+            System.arraycopy(b, 1, newarray, 0, n);
+            b = newarray;
+        }
+        return b;
+    }
+
+    static final class RSAPrivate extends NativeKey implements RSAPrivateKey {
+
+        private static final long serialVersionUID = 1622705588904302831L;
+
+        private final RSAPrivateKeySpec keySpec;
+        private final long keyId;
+
+        RSAPrivate(KeySpec keySpec) throws InvalidKeySpecException {
+            super(2);
+            long pKey = 0L;
+            if (keySpec instanceof RSAPrivateKeySpec) {
+                RSAPrivateKeySpec ks = (RSAPrivateKeySpec) keySpec;
+                BigInteger mod = ks.getModulus();
+                BigInteger privateExp =  ks.getPrivateExponent();
+                pKey = nativeInit(NativeKey.getMagnitude(mod),
+                                  NativeKey.getMagnitude(privateExp));
+            } else {
+                throw new InvalidKeySpecException("Only supports RSAPrivateKeySpec." +
+                    " Received: " + keySpec.getClass().getName());
+            }
+            if (pKey == 0L) {
+                throw new UcryptoException("Error constructing RSA PrivateKey");
+            }
+            // track native resource clean up
+            new KeyRef(this, pKey);
+            this.keySpec = (RSAPrivateKeySpec) keySpec;
+            this.keyId = pKey;
+        }
+
+        long value() { return keyId; }
+        public BigInteger getModulus() { return keySpec.getModulus(); };
+        public BigInteger getPrivateExponent() { return keySpec.getPrivateExponent(); };
+
+        private native static long nativeInit(byte[] mod, byte[] privExp);
+    }
+
+    static final class RSAPrivateCrt extends NativeKey implements RSAPrivateCrtKey {
+
+        private static final long serialVersionUID = 6812507588904302831L;
+
+        private final RSAPrivateCrtKeySpec keySpec;
+        private final long keyId;
+
+        RSAPrivateCrt(KeySpec keySpec) throws InvalidKeySpecException {
+            super(8);
+            long pKey = 0L;
+            if (keySpec instanceof RSAPrivateCrtKeySpec) {
+                RSAPrivateCrtKeySpec ks = (RSAPrivateCrtKeySpec) keySpec;
+                BigInteger mod = ks.getModulus();
+                BigInteger publicExp =  ks.getPublicExponent();
+                BigInteger privateExp =  ks.getPrivateExponent();
+                BigInteger primeP = ks.getPrimeP();
+                BigInteger primeQ = ks.getPrimeQ();
+                BigInteger primeExpP = ks.getPrimeExponentP();
+                BigInteger primeExpQ = ks.getPrimeExponentQ();
+                BigInteger crtCoeff = ks.getCrtCoefficient();
+                pKey = nativeInit(NativeKey.getMagnitude(mod),
+                                  NativeKey.getMagnitude(publicExp),
+                                  NativeKey.getMagnitude(privateExp),
+                                  NativeKey.getMagnitude(primeP),
+                                  NativeKey.getMagnitude(primeQ),
+                                  NativeKey.getMagnitude(primeExpP),
+                                  NativeKey.getMagnitude(primeExpQ),
+                                  NativeKey.getMagnitude(crtCoeff));
+            } else {
+                throw new InvalidKeySpecException("Only supports RSAPrivateCrtKeySpec."
+                    + " Received: " + keySpec.getClass().getName());
+            }
+            if (pKey == 0L) {
+                throw new UcryptoException("Error constructing RSA PrivateCrtKey");
+            }
+            // track native resource clean up
+            new KeyRef(this, pKey);
+            this.keySpec = (RSAPrivateCrtKeySpec) keySpec;
+            this.keyId = pKey;
+        }
+
+        long value() { return keyId; }
+        public BigInteger getModulus() { return keySpec.getModulus(); };
+        public BigInteger getPublicExponent() { return keySpec.getPublicExponent(); };
+        public BigInteger getPrivateExponent() { return keySpec.getPrivateExponent(); };
+        public BigInteger getPrimeP() { return keySpec.getPrimeP(); };
+        public BigInteger getPrimeQ() { return keySpec.getPrimeQ(); };
+        public BigInteger getPrimeExponentP() { return keySpec.getPrimeExponentP(); };
+        public BigInteger getPrimeExponentQ() { return keySpec.getPrimeExponentQ(); };
+        public BigInteger getCrtCoefficient() { return keySpec.getCrtCoefficient(); };
+
+        private native static long nativeInit(byte[] mod, byte[] pubExp, byte[] privExp,
+                                      byte[] p, byte[] q,
+                                      byte[] expP, byte[] expQ, byte[] crtCoeff);
+    }
+
+    static final class RSAPublic extends NativeKey implements RSAPublicKey {
+
+        private static final long serialVersionUID = 6812507588904302832L;
+
+        private final RSAPublicKeySpec keySpec;
+        private final long keyId;
+
+        RSAPublic(KeySpec keySpec) throws InvalidKeySpecException {
+            super(2);
+            long pKey = 0L;
+            if (keySpec instanceof RSAPublicKeySpec) {
+                RSAPublicKeySpec ks = (RSAPublicKeySpec) keySpec;
+                BigInteger mod = ks.getModulus();
+                BigInteger publicExp = ks.getPublicExponent();
+                pKey = nativeInit(NativeKey.getMagnitude(mod),
+                                  NativeKey.getMagnitude(publicExp));
+            } else {
+                throw new InvalidKeySpecException("Only supports RSAPublicKeySpec." +
+                    " Received: " + keySpec.getClass().getName());
+            }
+            if (pKey == 0L) {
+                throw new UcryptoException("Error constructing RSA PublicKey");
+            }
+            // track native resource clean up
+            new KeyRef(this, pKey);
+            this.keySpec = (RSAPublicKeySpec) keySpec;
+            this.keyId = pKey;
+        }
+
+        long value() { return keyId; }
+        public BigInteger getModulus() { return keySpec.getModulus(); };
+        public BigInteger getPublicExponent() { return keySpec.getPublicExponent(); };
+
+        private native static long nativeInit(byte[] mod, byte[] pubExp);
+    }
+
+    // internal class for native resource cleanup
+    private static class KeyRef extends PhantomReference<NativeKey>
+        implements Comparable<KeyRef> {
+
+        private static ReferenceQueue<NativeKey> refQueue =
+            new ReferenceQueue<NativeKey>();
+
+        // Needed to keep these references from being GC'ed until when their
+        // referents are GC'ed so we can do post-mortem processing
+        private static Set<KeyRef> refList =
+            new ConcurrentSkipListSet<KeyRef>();
+
+        private final long id;
+        private final int length;
+
+        private static void drainRefQueueBounded() {
+            while (true) {
+                KeyRef next = (KeyRef) refQueue.poll();
+                if (next == null) break;
+                next.dispose();
+            }
+        }
+
+        KeyRef(NativeKey nk, long id) {
+            super(nk, refQueue);
+            this.id = id;
+            this.length = nk.length();
+            refList.add(this);
+            UcryptoProvider.debug("Resource: track NativeKey " + this.id);
+            drainRefQueueBounded();
+        }
+
+        public int compareTo(KeyRef other) {
+            if (this.id == other.id) {
+                return 0;
+            } else {
+                return (this.id < other.id) ? -1 : 1;
+            }
+        }
+
+        void dispose() {
+            refList.remove(this);
+            UcryptoProvider.debug("Resource: free NativeKey " + this.id);
+            try {
+                NativeKey.nativeFree(id, length);
+            } finally {
+                this.clear();
+            }
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSACipher.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSACipher.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSACipher.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSACipher.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.Arrays;
+import java.util.WeakHashMap;
+import java.util.Collections;
+import java.util.Map;
+
+import java.security.AlgorithmParameters;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.Key;
+import java.security.PublicKey;
+import java.security.PrivateKey;
+import java.security.spec.RSAPrivateCrtKeySpec;
+import java.security.spec.RSAPrivateKeySpec;
+import java.security.spec.RSAPublicKeySpec;
+import java.security.interfaces.RSAKey;
+import java.security.interfaces.RSAPrivateCrtKey;
+import java.security.interfaces.RSAPrivateKey;
+import java.security.interfaces.RSAPublicKey;
+
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+
+import java.security.spec.AlgorithmParameterSpec;
+import java.security.spec.InvalidParameterSpecException;
+import java.security.spec.InvalidKeySpecException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.CipherSpi;
+import javax.crypto.SecretKey;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+
+import javax.crypto.spec.SecretKeySpec;
+
+import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;
+import sun.security.jca.JCAUtil;
+import sun.security.util.KeyUtil;
+
+/**
+ * Asymmetric Cipher wrapper class utilizing ucrypto APIs. This class
+ * currently supports
+ * - RSA/ECB/NOPADDING
+ * - RSA/ECB/PKCS1PADDING
+ *
+ * @since 9
+ */
+public class NativeRSACipher extends CipherSpi {
+    // fields set in constructor
+    private final UcryptoMech mech;
+    private final int padLen;
+    private final NativeRSAKeyFactory keyFactory;
+    private AlgorithmParameterSpec spec;
+    private SecureRandom random;
+
+    // Keep a cache of RSA keys and their RSA NativeKey for reuse.
+    // When the RSA key is gc'ed, we let NativeKey phatom references cleanup
+    // the native allocation
+    private static final Map<Key, NativeKey> keyList =
+            Collections.synchronizedMap(new WeakHashMap<Key, NativeKey>());
+
+    //
+    // fields (re)set in every init()
+    //
+    private NativeKey key = null;
+    private int outputSize = 0; // e.g. modulus size in bytes
+    private boolean encrypt = true;
+    private byte[] buffer;
+    private int bufOfs = 0;
+
+    // public implementation classes
+    public static final class NoPadding extends NativeRSACipher {
+        public NoPadding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_RSA_X_509, 0);
+        }
+    }
+
+    public static final class PKCS1Padding extends NativeRSACipher {
+        public PKCS1Padding() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_RSA_PKCS, 11);
+        }
+    }
+
+    NativeRSACipher(UcryptoMech mech, int padLen)
+        throws NoSuchAlgorithmException {
+        this.mech = mech;
+        this.padLen = padLen;
+        this.keyFactory = new NativeRSAKeyFactory();
+    }
+
+    @Override
+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
+        // Disallow change of mode for now since currently it's explicitly
+        // defined in transformation strings
+        throw new NoSuchAlgorithmException("Unsupported mode " + mode);
+    }
+
+    // see JCE spec
+    @Override
+    protected void engineSetPadding(String padding)
+            throws NoSuchPaddingException {
+        // Disallow change of padding for now since currently it's explicitly
+        // defined in transformation strings
+        throw new NoSuchPaddingException("Unsupported padding " + padding);
+    }
+
+    // see JCE spec
+    @Override
+    protected int engineGetBlockSize() {
+        return 0;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineGetOutputSize(int inputLen) {
+        return outputSize;
+    }
+
+    // see JCE spec
+    @Override
+    protected byte[] engineGetIV() {
+        return null;
+    }
+
+    // see JCE spec
+    @Override
+    protected AlgorithmParameters engineGetParameters() {
+        return null;
+    }
+
+    @Override
+    protected int engineGetKeySize(Key key) throws InvalidKeyException {
+        if (!(key instanceof RSAKey)) {
+            throw new InvalidKeyException("RSAKey required. Got: " +
+                key.getClass().getName());
+        }
+        int n = ((RSAKey)key).getModulus().bitLength();
+        // strip off the leading extra 0x00 byte prefix
+        int realByteSize = (n + 7) >> 3;
+        return realByteSize * 8;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key, SecureRandom random)
+            throws InvalidKeyException {
+        try {
+            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);
+        } catch (InvalidAlgorithmParameterException e) {
+            throw new InvalidKeyException("init() failed", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    @SuppressWarnings("deprecation")
+    protected synchronized void engineInit(int opmode, Key newKey,
+            AlgorithmParameterSpec params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        if (newKey == null) {
+            throw new InvalidKeyException("Key cannot be null");
+        }
+        if (opmode != Cipher.ENCRYPT_MODE &&
+            opmode != Cipher.DECRYPT_MODE &&
+            opmode != Cipher.WRAP_MODE &&
+            opmode != Cipher.UNWRAP_MODE) {
+            throw new InvalidAlgorithmParameterException
+                ("Unsupported mode: " + opmode);
+        }
+        if (params != null) {
+            if (!(params instanceof TlsRsaPremasterSecretParameterSpec)) {
+                throw new InvalidAlgorithmParameterException(
+                        "No Parameters can be specified");
+            }
+            spec = params;
+            if (random == null) {
+                random = JCAUtil.getSecureRandom();
+            }
+            this.random = random;   // for TLS RSA premaster secret
+        }
+        boolean doEncrypt = (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE);
+
+        // Make sure the proper opmode uses the proper key
+        if (doEncrypt && (!(newKey instanceof RSAPublicKey))) {
+            throw new InvalidKeyException("RSAPublicKey required for encryption." +
+                " Received: " + newKey.getClass().getName());
+        } else if (!doEncrypt && (!(newKey instanceof RSAPrivateKey))) {
+            throw new InvalidKeyException("RSAPrivateKey required for decryption." +
+                " Received: " + newKey.getClass().getName());
+        }
+
+        NativeKey nativeKey = null;
+        // Check keyList cache for a nativeKey
+        nativeKey = keyList.get(newKey);
+        if (nativeKey == null) {
+            // With no existing nativeKey for this newKey, create one
+            if (doEncrypt) {
+                RSAPublicKey publicKey = (RSAPublicKey) newKey;
+                try {
+                    nativeKey = (NativeKey) keyFactory.engineGeneratePublic
+                        (new RSAPublicKeySpec(publicKey.getModulus(), publicKey.getPublicExponent()));
+                } catch (InvalidKeySpecException ikse) {
+                    throw new InvalidKeyException(ikse);
+                }
+            } else {
+                try {
+                    if (newKey instanceof RSAPrivateCrtKey) {
+                        RSAPrivateCrtKey privateKey = (RSAPrivateCrtKey) newKey;
+                        nativeKey = (NativeKey) keyFactory.engineGeneratePrivate
+                            (new RSAPrivateCrtKeySpec(privateKey.getModulus(),
+                                                      privateKey.getPublicExponent(),
+                                                      privateKey.getPrivateExponent(),
+                                                      privateKey.getPrimeP(),
+                                                      privateKey.getPrimeQ(),
+                                                      privateKey.getPrimeExponentP(),
+                                                      privateKey.getPrimeExponentQ(),
+                                                      privateKey.getCrtCoefficient()));
+                    } else if (newKey instanceof RSAPrivateKey) {
+                        RSAPrivateKey privateKey = (RSAPrivateKey) newKey;
+                        nativeKey = (NativeKey) keyFactory.engineGeneratePrivate
+                            (new RSAPrivateKeySpec(privateKey.getModulus(),
+                                                   privateKey.getPrivateExponent()));
+                    } else {
+                        throw new InvalidKeyException("Unsupported type of RSAPrivateKey." +
+                            " Received: " + newKey.getClass().getName());
+                    }
+                } catch (InvalidKeySpecException ikse) {
+                    throw new InvalidKeyException(ikse);
+                }
+            }
+
+            // Add nativeKey to keyList cache and associate it with newKey
+            keyList.put(newKey, nativeKey);
+        }
+
+        init(doEncrypt, nativeKey);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized void engineInit(int opmode, Key key, AlgorithmParameters params,
+            SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        if (params != null) {
+            throw new InvalidAlgorithmParameterException("No Parameters can be specified");
+        }
+        engineInit(opmode, key, (AlgorithmParameterSpec) null, random);
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
+        if (inLen > 0) {
+            update(in, inOfs, inLen);
+        }
+        return null;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,
+            int outOfs) throws ShortBufferException {
+        if (out.length - outOfs < outputSize) {
+            throw new ShortBufferException("Output buffer too small. outputSize: " +
+                outputSize + ". out.length: " + out.length + ". outOfs: " + outOfs);
+        }
+        if (inLen > 0) {
+            update(in, inOfs, inLen);
+        }
+        return 0;
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
+            throws IllegalBlockSizeException, BadPaddingException {
+        byte[] out = new byte[outputSize];
+        try {
+            // delegate to the other engineDoFinal(...) method
+            int actualLen = engineDoFinal(in, inOfs, inLen, out, 0);
+            if (actualLen != outputSize) {
+                return Arrays.copyOf(out, actualLen);
+            } else {
+                return out;
+            }
+        } catch (ShortBufferException e) {
+            throw new UcryptoException("Internal Error", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    protected synchronized int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,
+                                             int outOfs)
+        throws ShortBufferException, IllegalBlockSizeException,
+               BadPaddingException {
+        if (inLen != 0) {
+            update(in, inOfs, inLen);
+        }
+        return doFinal(out, outOfs, out.length - outOfs);
+    }
+
+
+    // see JCE spec
+    @Override
+    protected synchronized byte[] engineWrap(Key key) throws IllegalBlockSizeException,
+                                                             InvalidKeyException {
+        try {
+            byte[] encodedKey = key.getEncoded();
+            if ((encodedKey == null) || (encodedKey.length == 0)) {
+                throw new InvalidKeyException("Cannot get an encoding of " +
+                                              "the key to be wrapped");
+            }
+            if (encodedKey.length > buffer.length) {
+                throw new InvalidKeyException("Key is too long for wrapping. " +
+                    "encodedKey.length: " + encodedKey.length +
+                    ". buffer.length: " + buffer.length);
+            }
+            return engineDoFinal(encodedKey, 0, encodedKey.length);
+        } catch (BadPaddingException e) {
+            // Should never happen for key wrapping
+            throw new UcryptoException("Internal Error", e);
+        }
+    }
+
+    // see JCE spec
+    @Override
+    @SuppressWarnings("deprecation")
+    protected synchronized Key engineUnwrap(byte[] wrappedKey,
+            String wrappedKeyAlgorithm, int wrappedKeyType)
+            throws InvalidKeyException, NoSuchAlgorithmException {
+
+        if (wrappedKey.length > buffer.length) {
+            throw new InvalidKeyException("Key is too long for unwrapping." +
+                " wrappedKey.length: " + wrappedKey.length +
+                ". buffer.length: " + buffer.length);
+        }
+
+        boolean isTlsRsaPremasterSecret =
+                wrappedKeyAlgorithm.equals("TlsRsaPremasterSecret");
+        Exception failover = null;
+
+        byte[] encodedKey = null;
+        try {
+            encodedKey = engineDoFinal(wrappedKey, 0, wrappedKey.length);
+        } catch (BadPaddingException bpe) {
+            if (isTlsRsaPremasterSecret) {
+                failover = bpe;
+            } else {
+                throw new InvalidKeyException("Unwrapping failed", bpe);
+            }
+        } catch (Exception e) {
+            throw new InvalidKeyException("Unwrapping failed", e);
+        }
+
+        if (isTlsRsaPremasterSecret) {
+            if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {
+                throw new IllegalStateException(
+                        "No TlsRsaPremasterSecretParameterSpec specified");
+            }
+
+            // polish the TLS premaster secret
+            encodedKey = KeyUtil.checkTlsPreMasterSecretKey(
+                ((TlsRsaPremasterSecretParameterSpec)spec).getClientVersion(),
+                ((TlsRsaPremasterSecretParameterSpec)spec).getServerVersion(),
+                random, encodedKey, (failover != null));
+        }
+
+        return NativeCipher.constructKey(wrappedKeyType,
+                encodedKey, wrappedKeyAlgorithm);
+    }
+
+    /**
+     * calls ucrypto_encrypt(...) or ucrypto_decrypt(...)
+     * @return the length of output or an negative error status code
+     */
+    private native static int nativeAtomic(int mech, boolean encrypt,
+                                           long keyValue, int keyLength,
+                                           byte[] in, int inLen,
+                                           byte[] out, int ouOfs, int outLen);
+
+    // do actual initialization
+    private void init(boolean encrypt, NativeKey key) {
+        this.encrypt = encrypt;
+        this.key = key;
+        try {
+            this.outputSize = engineGetKeySize(key)/8;
+        } catch (InvalidKeyException ike) {
+            throw new UcryptoException("Internal Error", ike);
+        }
+        this.buffer = new byte[outputSize];
+        this.bufOfs = 0;
+    }
+
+    // store the specified input into the internal buffer
+    private void update(byte[] in, int inOfs, int inLen) {
+        if ((inLen <= 0) || (in == null)) {
+            return;
+        }
+        // buffer bytes internally until doFinal is called
+        if ((bufOfs + inLen + (encrypt? padLen:0)) > buffer.length) {
+            // lead to IllegalBlockSizeException when doFinal() is called
+            bufOfs = buffer.length + 1;
+            return;
+        }
+        System.arraycopy(in, inOfs, buffer, bufOfs, inLen);
+        bufOfs += inLen;
+    }
+
+    // return the actual non-negative output length
+    private int doFinal(byte[] out, int outOfs, int outLen)
+            throws ShortBufferException, IllegalBlockSizeException,
+            BadPaddingException {
+        if (bufOfs > buffer.length) {
+            throw new IllegalBlockSizeException(
+                "Data must not be longer than " +
+                (buffer.length - (encrypt ? padLen : 0)) + " bytes");
+        }
+        if (outLen < outputSize) {
+            throw new ShortBufferException();
+        }
+        try {
+            long keyValue = key.value();
+            int k = nativeAtomic(mech.value(), encrypt, keyValue,
+                                 key.length(), buffer, bufOfs,
+                                 out, outOfs, outLen);
+            if (k < 0) {
+                if ( k == -16 || k == -64) {
+                    // -16: CRYPTO_ENCRYPTED_DATA_INVALID
+                    // -64: CKR_ENCRYPTED_DATA_INVALID, see bug 17459266
+                    UcryptoException ue = new UcryptoException(16);
+                    BadPaddingException bpe =
+                        new BadPaddingException("Invalid encryption data");
+                    bpe.initCause(ue);
+                    throw bpe;
+                }
+                throw new UcryptoException(-k);
+            }
+
+            return k;
+        } finally {
+            bufOfs = 0;
+        }
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSAKeyFactory.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSAKeyFactory.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSAKeyFactory.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSAKeyFactory.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.Set;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+
+import java.math.BigInteger;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.Key;
+import java.security.PublicKey;
+import java.security.PrivateKey;
+import java.security.KeyFactorySpi;
+
+import java.security.spec.*;
+
+/**
+ * Ucrypto-private KeyFactory class for generating native keys
+ * needed for using ucrypto APIs.
+ *
+ * @since 9
+ */
+public final class NativeRSAKeyFactory extends KeyFactorySpi {
+
+    @Override
+    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)
+        throws InvalidKeySpecException {
+        if (keySpec instanceof RSAPrivateCrtKeySpec) {
+            return new NativeKey.RSAPrivateCrt(keySpec);
+        } else if (keySpec instanceof RSAPrivateKeySpec) {
+            return new NativeKey.RSAPrivate(keySpec);
+        } else {
+            throw new InvalidKeySpecException("Unsupported key spec." +
+                " Received: " + keySpec.getClass().getName());
+        }
+    }
+
+    @Override
+    protected PublicKey engineGeneratePublic(KeySpec keySpec)
+        throws InvalidKeySpecException {
+        return new NativeKey.RSAPublic(keySpec);
+    }
+
+    @Override
+    protected <T extends KeySpec> T
+        engineGetKeySpec(Key key, Class<T> keySpec)
+            throws InvalidKeySpecException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected Key engineTranslateKey(Key key) throws InvalidKeyException {
+        // no need to support this
+        throw new UnsupportedOperationException();
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSASignature.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSASignature.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/NativeRSASignature.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/NativeRSASignature.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,485 @@
+/*
+ * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.Set;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.lang.ref.*;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+
+import java.security.SignatureSpi;
+import java.security.NoSuchAlgorithmException;
+import java.security.InvalidParameterException;
+import java.security.InvalidKeyException;
+import java.security.SignatureException;
+import java.security.Key;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+
+import java.security.*;
+import java.security.interfaces.*;
+import java.security.spec.*;
+
+import sun.nio.ch.DirectBuffer;
+import java.nio.ByteBuffer;
+
+/**
+ * Signature implementation class. This class currently supports the
+ * following algorithms:
+ *
+ * . RSA:
+ *   . MD5withRSA
+ *   . SHA1withRSA
+ *   . SHA256withRSA
+ *   . SHA384withRSA
+ *   . SHA512withRSA
+ *
+ * @since 9
+ */
+class NativeRSASignature extends SignatureSpi {
+
+    private static final int PKCS1PADDING_LEN = 11;
+
+    // fields set in constructor
+    private final UcryptoMech mech;
+    private final int encodedLen;
+
+    // field for ensuring native memory is freed
+    private SignatureContextRef pCtxt = null;
+
+    //
+    // fields (re)set in every init()
+    //
+    private boolean initialized = false;
+    private boolean sign = true;
+    private int sigLength;
+    private NativeKey key;
+    private NativeRSAKeyFactory keyFactory; // may need a more generic type later
+
+    // public implementation classes
+    public static final class MD5 extends NativeRSASignature {
+        public MD5() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_MD5_RSA_PKCS, 34);
+        }
+    }
+
+    public static final class SHA1 extends NativeRSASignature {
+        public SHA1() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_SHA1_RSA_PKCS, 35);
+        }
+    }
+
+    public static final class SHA256 extends NativeRSASignature {
+        public SHA256() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_SHA256_RSA_PKCS, 51);
+        }
+    }
+
+    public static final class SHA384 extends NativeRSASignature {
+        public SHA384() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_SHA384_RSA_PKCS, 67);
+        }
+    }
+
+    public static final class SHA512 extends NativeRSASignature {
+        public SHA512() throws NoSuchAlgorithmException {
+            super(UcryptoMech.CRYPTO_SHA512_RSA_PKCS, 83);
+        }
+    }
+
+    // internal class for native resource cleanup
+    private static class SignatureContextRef extends PhantomReference<NativeRSASignature>
+        implements Comparable<SignatureContextRef> {
+
+        private static ReferenceQueue<NativeRSASignature> refQueue =
+            new ReferenceQueue<NativeRSASignature>();
+
+        // Needed to keep these references from being GC'ed until when their
+        // referents are GC'ed so we can do post-mortem processing
+        private static Set<SignatureContextRef> refList =
+            new ConcurrentSkipListSet<SignatureContextRef>();
+        //           Collections.synchronizedSortedSet(new TreeSet<SignatureContextRef>());
+
+        private final long id;
+        private final boolean sign;
+
+        private static void drainRefQueueBounded() {
+            while (true) {
+                SignatureContextRef next = (SignatureContextRef) refQueue.poll();
+                if (next == null) break;
+                next.dispose(true);
+            }
+        }
+
+        SignatureContextRef(NativeRSASignature ns, long id, boolean sign) {
+            super(ns, refQueue);
+            this.id = id;
+            this.sign = sign;
+            refList.add(this);
+            UcryptoProvider.debug("Resource: track Signature Ctxt " + this.id);
+            drainRefQueueBounded();
+        }
+
+        public int compareTo(SignatureContextRef other) {
+            if (this.id == other.id) {
+                return 0;
+            } else {
+                return (this.id < other.id) ? -1 : 1;
+            }
+        }
+
+        void dispose(boolean doCancel) {
+            refList.remove(this);
+            try {
+                if (doCancel) {
+                    UcryptoProvider.debug("Resource: free Signature Ctxt " + this.id);
+                    NativeRSASignature.nativeFinal(id, sign, null, 0, 0);
+                } else {
+                    UcryptoProvider.debug("Resource: stop tracking Signature Ctxt " + this.id);
+                }
+            } finally {
+                this.clear();
+            }
+        }
+    }
+
+    NativeRSASignature(UcryptoMech mech, int encodedLen)
+        throws NoSuchAlgorithmException {
+        this.mech = mech;
+        this.encodedLen = encodedLen;
+        this.keyFactory = new NativeRSAKeyFactory();
+    }
+
+    // deprecated but abstract
+    @Override
+    @SuppressWarnings("deprecation")
+    protected Object engineGetParameter(String param) throws InvalidParameterException {
+        throw new UnsupportedOperationException("getParameter() not supported");
+    }
+
+    @Override
+    protected AlgorithmParameters engineGetParameters() {
+        return null;
+    }
+
+    @Override
+    protected synchronized void engineInitSign(PrivateKey privateKey)
+            throws InvalidKeyException {
+        if (privateKey == null) {
+            throw new InvalidKeyException("Key must not be null");
+        }
+        NativeKey newKey = key;
+        int newSigLength = sigLength;
+        // Need to check RSA key length whenever a new private key is set
+        if (privateKey != key) {
+            if (!(privateKey instanceof RSAPrivateKey)) {
+                throw new InvalidKeyException("RSAPrivateKey required. " +
+                    "Received: " + privateKey.getClass().getName());
+            }
+            RSAPrivateKey rsaPrivKey = (RSAPrivateKey) privateKey;
+            BigInteger mod = rsaPrivKey.getModulus();
+            newSigLength = checkRSAKeyLength(mod);
+            BigInteger pe = rsaPrivKey.getPrivateExponent();
+            try {
+                if (rsaPrivKey instanceof RSAPrivateCrtKey) {
+                    RSAPrivateCrtKey rsaPrivCrtKey = (RSAPrivateCrtKey) rsaPrivKey;
+                    newKey = (NativeKey) keyFactory.engineGeneratePrivate
+                        (new RSAPrivateCrtKeySpec(mod,
+                                                  rsaPrivCrtKey.getPublicExponent(),
+                                                  pe,
+                                                  rsaPrivCrtKey.getPrimeP(),
+                                                  rsaPrivCrtKey.getPrimeQ(),
+                                                  rsaPrivCrtKey.getPrimeExponentP(),
+                                                  rsaPrivCrtKey.getPrimeExponentQ(),
+                                                  rsaPrivCrtKey.getCrtCoefficient()));
+                } else {
+                    newKey = (NativeKey) keyFactory.engineGeneratePrivate
+                           (new RSAPrivateKeySpec(mod, pe));
+                }
+            } catch (InvalidKeySpecException ikse) {
+                throw new InvalidKeyException(ikse);
+            }
+        }
+        init(true, newKey, newSigLength);
+    }
+
+
+    @Override
+    protected synchronized void engineInitVerify(PublicKey publicKey)
+            throws InvalidKeyException {
+        if (publicKey == null) {
+            throw new InvalidKeyException("Key must not be null");
+        }
+        NativeKey newKey = key;
+        int newSigLength = sigLength;
+        // Need to check RSA key length whenever a new public key is set
+        if (publicKey != key) {
+            if (publicKey instanceof RSAPublicKey) {
+                BigInteger mod = ((RSAPublicKey) publicKey).getModulus();
+                newSigLength = checkRSAKeyLength(mod);
+                try {
+                    newKey = (NativeKey) keyFactory.engineGeneratePublic
+                        (new RSAPublicKeySpec(mod, ((RSAPublicKey) publicKey).getPublicExponent()));
+                } catch (InvalidKeySpecException ikse) {
+                    throw new InvalidKeyException(ikse);
+                }
+            } else {
+                throw new InvalidKeyException("RSAPublicKey required. " +
+                    "Received: " + publicKey.getClass().getName());
+            }
+        }
+        init(false, newKey, newSigLength);
+    }
+
+    // deprecated but abstract
+    @Override
+    @SuppressWarnings("deprecation")
+    protected void engineSetParameter(String param, Object value) throws InvalidParameterException {
+        throw new UnsupportedOperationException("setParameter() not supported");
+    }
+
+    @Override
+    protected void engineSetParameter(AlgorithmParameterSpec params)
+            throws InvalidAlgorithmParameterException {
+        if (params != null) {
+            throw new InvalidAlgorithmParameterException("No parameter accepted");
+        }
+    }
+
+    @Override
+    protected synchronized byte[] engineSign() throws SignatureException {
+        try {
+            byte[] sig = new byte[sigLength];
+            int rv = doFinal(sig, 0, sigLength);
+            if (rv < 0) {
+                throw new SignatureException(new UcryptoException(-rv));
+            }
+            return sig;
+        } finally {
+            // doFinal should already be called, no need to cancel
+            reset(false);
+        }
+    }
+
+    @Override
+    protected synchronized int engineSign(byte[] outbuf, int offset, int len)
+        throws SignatureException {
+        boolean doCancel = true;
+        try {
+            if (outbuf == null || (offset < 0) ||
+                    ((outbuf.length - offset) < sigLength) ||
+                    (len < sigLength)) {
+                throw new SignatureException("Invalid output buffer. offset: " +
+                    offset + ". len: " + len + ". sigLength: " + sigLength);
+            }
+            int rv = doFinal(outbuf, offset, sigLength);
+            doCancel = false;
+            if (rv < 0) {
+                throw new SignatureException(new UcryptoException(-rv));
+            }
+            return sigLength;
+        } finally {
+            reset(doCancel);
+        }
+    }
+
+    @Override
+    protected synchronized void engineUpdate(byte b) throws SignatureException {
+        byte[] in = { b };
+        int rv = update(in, 0, 1);
+        if (rv < 0) {
+            throw new SignatureException(new UcryptoException(-rv));
+        }
+    }
+
+    @Override
+    protected synchronized void engineUpdate(byte[] in, int inOfs, int inLen)
+            throws SignatureException {
+        if (in == null || inOfs < 0 || inLen == 0) return;
+
+        int rv = update(in, inOfs, inLen);
+        if (rv < 0) {
+            throw new SignatureException(new UcryptoException(-rv));
+        }
+    }
+
+    @Override
+    protected synchronized void engineUpdate(ByteBuffer in) {
+        if (in == null || in.remaining() == 0) return;
+
+        if (in instanceof DirectBuffer == false) {
+            // cannot do better than default impl
+            super.engineUpdate(in);
+            return;
+        }
+        long inAddr = ((DirectBuffer)in).address();
+        int inOfs = in.position();
+        int inLen = in.remaining();
+
+        int rv = update((inAddr + inOfs), inLen);
+        if (rv < 0) {
+            throw new UcryptoException(-rv);
+        }
+        in.position(inOfs + inLen);
+    }
+
+    @Override
+    protected synchronized boolean engineVerify(byte[] sigBytes) throws SignatureException {
+        return engineVerify(sigBytes, 0, sigBytes.length);
+    }
+
+    @Override
+    protected synchronized boolean engineVerify(byte[] sigBytes, int sigOfs, int sigLen)
+        throws SignatureException {
+        boolean doCancel = true;
+        try {
+            if (sigBytes == null || (sigOfs < 0) ||
+                    ((sigBytes.length - sigOfs) < this.sigLength) ||
+                    (sigLen != this.sigLength)) {
+                throw new SignatureException("Invalid signature length: got " +
+                    sigLen + " but was expecting " + this.sigLength);
+            }
+
+            int rv = doFinal(sigBytes, sigOfs, sigLen);
+            doCancel = false;
+            if (rv == 0) {
+                return true;
+            } else {
+                UcryptoProvider.debug("Signature: " + mech + " verification error " +
+                             new UcryptoException(-rv).getMessage());
+                return false;
+            }
+        } finally {
+            reset(doCancel);
+        }
+    }
+
+    void reset(boolean doCancel) {
+        initialized = false;
+        if (pCtxt != null) {
+            pCtxt.dispose(doCancel);
+            pCtxt = null;
+        }
+    }
+
+    /**
+     * calls ucrypto_sign_init(...) or ucrypto_verify_init(...)
+     * @return pointer to the context
+     */
+    private native static long nativeInit(int mech, boolean sign,
+                                          long keyValue, int keyLength);
+
+    /**
+     * calls ucrypto_sign_update(...) or ucrypto_verify_update(...)
+     * @return an error status code (0 means SUCCESS)
+     */
+    private native static int nativeUpdate(long pContext, boolean sign,
+                                           byte[] in, int inOfs, int inLen);
+    /**
+     * calls ucrypto_sign_update(...) or ucrypto_verify_update(...)
+     * @return an error status code (0 means SUCCESS)
+     */
+    private native static int nativeUpdate(long pContext, boolean sign,
+                                           long pIn, int inLen);
+
+    /**
+     * calls ucrypto_sign_final(...) or ucrypto_verify_final(...)
+     * @return the length of signature bytes or verification status.
+     * If negative, it indicates an error status code
+     */
+    private native static int nativeFinal(long pContext, boolean sign,
+                                          byte[] sig, int sigOfs, int sigLen);
+
+    // actual init() implementation - caller should clone key if needed
+    private void init(boolean sign, NativeKey key, int sigLength) {
+        reset(true);
+        this.sign = sign;
+        this.sigLength = sigLength;
+        this.key = key;
+        long pCtxtVal = nativeInit(mech.value(), sign, key.value(),
+                                   key.length());
+        initialized = (pCtxtVal != 0L);
+        if (initialized) {
+            pCtxt = new SignatureContextRef(this, pCtxtVal, sign);
+        } else {
+            throw new UcryptoException("Cannot initialize Signature");
+        }
+    }
+
+    private void ensureInitialized() {
+        if (!initialized) {
+            init(sign, key, sigLength);
+            if (!initialized) {
+                throw new UcryptoException("Cannot initialize Signature");
+            }
+        }
+    }
+
+    // returns 0 (success) or negative (ucrypto error occurred)
+    private int update(byte[] in, int inOfs, int inLen) {
+        if (inOfs < 0 || inOfs > (in.length - inLen)) {
+            throw new ArrayIndexOutOfBoundsException("inOfs :" + inOfs +
+                ". inLen: " + inLen + ". in.length: " + in.length);
+        }
+        ensureInitialized();
+        int k = nativeUpdate(pCtxt.id, sign, in, inOfs, inLen);
+        if (k < 0) {
+            reset(false);
+        }
+        return k;
+    }
+
+    // returns 0 (success) or negative (ucrypto error occurred)
+    private int update(long pIn, int inLen) {
+        ensureInitialized();
+        int k = nativeUpdate(pCtxt.id, sign, pIn, inLen);
+        if (k < 0) {
+            reset(false);
+        }
+        return k;
+    }
+
+    // returns 0 (success) or negative (ucrypto error occurred)
+    private int doFinal(byte[] sigBytes, int sigOfs, int sigLen) {
+        ensureInitialized();
+        int k = nativeFinal(pCtxt.id, sign, sigBytes, sigOfs, sigLen);
+        return k;
+    }
+
+    // check and return RSA key size in number of bytes
+    private int checkRSAKeyLength(BigInteger mod) throws InvalidKeyException {
+        int keySize = (mod.bitLength() + 7) >> 3;
+        int maxDataSize = keySize - PKCS1PADDING_LEN;
+        if (maxDataSize < encodedLen) {
+            throw new InvalidKeyException
+                ("Key is too short for this signature algorithm. maxDataSize: " +
+                    maxDataSize + ". encodedLen: " + encodedLen);
+        }
+        return keySize;
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/ServiceDesc.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/ServiceDesc.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/ServiceDesc.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/ServiceDesc.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.*;
+
+/**
+ * Class for encapsulating the type, algorithm, and class name of
+ * a Provider.Service object.
+ */
+final class ServiceDesc {
+
+    private final String type;
+    private final String algo;
+    private final String cn;
+    private final List<String> aliases;
+
+    ServiceDesc(String type, String algo, String cn) {
+        this(type, algo, cn, null);
+    }
+
+    ServiceDesc(String type, String algo, String cn, List<String> aliases) {
+        this.type = type;
+        this.algo = algo;
+        this.cn = cn;
+        this.aliases = aliases;
+    }
+    String getType() {
+        return type;
+    }
+    String getAlgorithm() {
+        return algo;
+    }
+    String getClassName() {
+        return cn;
+    }
+    List<String> getAliases() {
+        return aliases;
+    }
+    public String toString() {
+        return type + "." + algo + ": " + cn + ", aliases =" + aliases;
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoException.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoException.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoException.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoException.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.*;
+import java.security.ProviderException;
+
+/**
+ * The exception class used by SunUcrypto provider. An exception
+ * object of this class indicates that a function call to the underlying
+ * native calls returned a value not equal to CRYPTO_SUCCESS.
+ *
+ * @since 9
+ */
+public final class UcryptoException extends ProviderException {
+
+    private static final long serialVersionUID = -933864511110035746L;
+
+    // NOTE: check /usr/include/sys/crypto/common.h for updates
+    public enum Error {
+        CRYPTO_SUCCESS,
+        CRYPTO_CANCEL,
+        CRYPTO_HOST_MEMORY,
+        CRYPTO_GENERAL_ERROR,
+        CRYPTO_FAILED,
+        CRYPTO_ARGUMENTS_BAD,
+        CRYPTO_ATTRIBUTE_READ_ONLY,
+        CRYPTO_ATTRIBUTE_SENSITIVE,
+        CRYPTO_ATTRIBUTE_TYPE_INVALID,
+        CRYPTO_ATTRIBUTE_VALUE_INVALID,
+        CRYPTO_CANCELED,
+        CRYPTO_DATA_INVALID,
+        CRYPTO_DATA_LEN_RANGE,
+        CRYPTO_DEVICE_ERROR,
+        CRYPTO_DEVICE_MEMORY,
+        CRYPTO_DEVICE_REMOVED,
+        CRYPTO_ENCRYPTED_DATA_INVALID,
+        CRYPTO_ENCRYPTED_DATA_LEN_RANGE,
+        CRYPTO_KEY_HANDLE_INVALID,
+        CRYPTO_KEY_SIZE_RANGE,
+        CRYPTO_KEY_TYPE_INCONSISTENT,
+        CRYPTO_KEY_NOT_NEEDED,
+        CRYPTO_KEY_CHANGED,
+        CRYPTO_KEY_NEEDED,
+        CRYPTO_KEY_INDIGESTIBLE,
+        CRYPTO_KEY_FUNCTION_NOT_PERMITTED,
+        CRYPTO_KEY_NOT_WRAPPABLE,
+        CRYPTO_KEY_UNEXTRACTABLE,
+        CRYPTO_MECHANISM_INVALID,
+        CRYPTO_MECHANISM_PARAM_INVALID,
+        CRYPTO_OBJECT_HANDLE_INVALID,
+        CRYPTO_OPERATION_IS_ACTIVE,
+        CRYPTO_OPERATION_NOT_INITIALIZED,
+        CRYPTO_PIN_INCORRECT,
+        CRYPTO_PIN_INVALID,
+        CRYPTO_PIN_LEN_RANGE,
+        CRYPTO_PIN_EXPIRED,
+        CRYPTO_PIN_LOCKED,
+        CRYPTO_SESSION_CLOSED,
+        CRYPTO_SESSION_COUNT,
+        CRYPTO_SESSION_HANDLE_INVALID,
+        CRYPTO_SESSION_READ_ONLY,
+        CRYPTO_SESSION_EXISTS,
+        CRYPTO_SESSION_READ_ONLY_EXISTS,
+        CRYPTO_SESSION_READ_WRITE_SO_EXISTS,
+        CRYPTO_SIGNATURE_INVALID,
+        CRYPTO_SIGNATURE_LEN_RANGE,
+        CRYPTO_TEMPLATE_INCOMPLETE,
+        CRYPTO_TEMPLATE_INCONSISTENT,
+        CRYPTO_UNWRAPPING_KEY_HANDLE_INVALID,
+        CRYPTO_UNWRAPPING_KEY_SIZE_RANGE,
+        CRYPTO_UNWRAPPING_KEY_TYPE_INCONSISTENT,
+        CRYPTO_USER_ALREADY_LOGGED_IN,
+        CRYPTO_USER_NOT_LOGGED_IN,
+        CRYPTO_USER_PIN_NOT_INITIALIZED,
+        CRYPTO_USER_TYPE_INVALID,
+        CRYPTO_USER_ANOTHER_ALREADY_LOGGED_IN,
+        CRYPTO_USER_TOO_MANY_TYPES,
+        CRYPTO_WRAPPED_KEY_INVALID,
+        CRYPTO_WRAPPED_KEY_LEN_RANGE,
+        CRYPTO_WRAPPING_KEY_HANDLE_INVALID,
+        CRYPTO_WRAPPING_KEY_SIZE_RANGE,
+        CRYPTO_WRAPPING_KEY_TYPE_INCONSISTENT,
+        CRYPTO_RANDOM_SEED_NOT_SUPPORTED,
+        CRYPTO_RANDOM_NO_RNG,
+        CRYPTO_DOMAIN_PARAMS_INVALID,
+        CRYPTO_BUFFER_TOO_SMALL,
+        CRYPTO_INFORMATION_SENSITIVE,
+        CRYPTO_NOT_SUPPORTED,
+        CRYPTO_QUEUED,
+        CRYPTO_BUFFER_TOO_BIG,
+        CRYPTO_INVALID_CONTEXT,
+        CRYPTO_INVALID_MAC,
+        CRYPTO_MECH_NOT_SUPPORTED,
+        CRYPTO_INCONSISTENT_ATTRIBUTE,
+        CRYPTO_NO_PERMISSION,
+        CRYPTO_INVALID_PROVIDER_ID,
+        CRYPTO_VERSION_MISMATCH,
+        CRYPTO_BUSY,
+        CRYPTO_UNKNOWN_PROVIDER,
+        CRYPTO_MODVERIFICATION_FAILED,
+        CRYPTO_OLD_CTX_TEMPLATE,
+        CRYPTO_WEAK_KEY,
+        CRYPTO_FIPS140_ERROR;
+    };
+
+    // Array used to look up error by ordinal
+    private static final Error[] ALL_ERRORS = Error.values();
+
+    /**
+     * Get the error enum value (if any) associated with this exception.
+     */
+    public Error getError() {
+        return (errorCode >= 0 && errorCode < ALL_ERRORS.length) ?
+            ALL_ERRORS[errorCode] :
+            null;
+    }
+
+    /**
+     * The error code if this exception is triggered by a Ucrypto error.
+     */
+    private final int errorCode;
+
+    /**
+     * This method gets the corresponding text error message from a
+     * predefined mapping. If mapping is not found, then it returns the error
+     * code as a hex-string.
+     *
+     * @return The message or the error code; e.g. "CRYPTO_DATA_INVALID" or
+     *         "0x88".
+     */
+    static String getErrorMessage(int errorCode) {
+        String message;
+        if (errorCode >= 0 && errorCode < ALL_ERRORS.length) {
+            message = ALL_ERRORS[errorCode].name();
+        } else {
+            message = "0x" + Integer.toHexString(errorCode);
+        }
+        return message;
+    }
+
+    /**
+     * Constructor taking the error code as defined for the CRYPTO_* constants
+     */
+    public UcryptoException(int rv) {
+        super(getErrorMessage(rv));
+        this.errorCode = rv;
+    }
+
+    public UcryptoException(String message) {
+        super(message);
+        errorCode = -1;
+    }
+
+    public UcryptoException(String message, Throwable cause) {
+        super(message, cause);
+        errorCode = -1;
+    }
+
+    /**
+     * Returns the Ucrypto error code.
+     *
+     * @return The error code.
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoMech.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoMech.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoMech.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoMech.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.util.List;
+import static sun.security.util.SecurityProviderConstants.getAliases;
+
+/**
+ * Enum for representing the ucrypto mechanisms.
+ *
+ * @since 9
+ */
+// Check /usr/include/libsoftcrypto.h for updates
+public enum UcryptoMech {
+
+    CRYPTO_AES_ECB(new ServiceDesc[]
+        { sd("Cipher", "AES/ECB/NoPadding", "com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding"),
+          sd("Cipher", "AES/ECB/PKCS5Padding", "com.oracle.security.ucrypto.NativeCipherWithJavaPadding$AesEcbPKCS5",
+             List.of("AES")),
+          sdA("Cipher", "AES_128/ECB/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding"),
+          sdA("Cipher", "AES_192/ECB/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding"),
+          sdA("Cipher", "AES_256/ECB/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding")
+        }),
+    CRYPTO_AES_CBC(new ServiceDesc[]
+        { sd("Cipher", "AES/CBC/NoPadding", "com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding"),
+          sd("Cipher", "AES/CBC/PKCS5Padding", "com.oracle.security.ucrypto.NativeCipherWithJavaPadding$AesCbcPKCS5"),
+          sdA("Cipher", "AES_128/CBC/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding"),
+          sdA("Cipher", "AES_192/CBC/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding"),
+          sdA("Cipher", "AES_256/CBC/NoPadding",
+              "com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding")
+        }),
+//  CRYPTO_AES_CBC_PAD(null), // Support added since S11.1; however we still use CRYPTO_AES_CBC due to known bug
+    CRYPTO_AES_CTR(new ServiceDesc[]
+        { sd("Cipher", "AES/CTR/NoPadding", "com.oracle.security.ucrypto.NativeCipher$AesCtrNoPadding") }),
+//  CRYPTO_AES_CCM(null), // Need Java API for CK_AES_CCM_PARAMS
+    CRYPTO_AES_GCM(new ServiceDesc[]
+        { sd("Cipher", "AES/GCM/NoPadding", "com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding"),
+          sdA("Cipher", "AES_128/GCM/NoPadding",
+              "com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding"),
+          sdA("Cipher", "AES_192/GCM/NoPadding",
+              "com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding"),
+          sdA("Cipher", "AES_256/GCM/NoPadding",
+              "com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding")
+        }),
+//  CRYPTO_AES_GMAC(null), // No support from Solaris
+    CRYPTO_AES_CFB128(new ServiceDesc[]
+        { sd("Cipher", "AES/CFB128/NoPadding", "com.oracle.security.ucrypto.NativeCipher$AesCfb128NoPadding"),
+          sd("Cipher", "AES/CFB128/PKCS5Padding", "com.oracle.security.ucrypto.NativeCipherWithJavaPadding$AesCfb128PKCS5")
+        }),
+
+    CRYPTO_RSA_PKCS(new ServiceDesc[]
+        { sd("Cipher", "RSA/ECB/PKCS1Padding", "com.oracle.security.ucrypto.NativeRSACipher$PKCS1Padding",
+             List.of("RSA"))
+        }),
+    CRYPTO_RSA_X_509(new ServiceDesc[]
+        { sd("Cipher", "RSA/ECB/NoPadding", "com.oracle.security.ucrypto.NativeRSACipher$NoPadding") }),
+    CRYPTO_MD5_RSA_PKCS(new ServiceDesc[]
+        { sdA("Signature", "MD5withRSA",
+              "com.oracle.security.ucrypto.NativeRSASignature$MD5")
+        }),
+    CRYPTO_SHA1_RSA_PKCS(new ServiceDesc[]
+        { sdA("Signature", "SHA1withRSA",
+              "com.oracle.security.ucrypto.NativeRSASignature$SHA1")
+        }),
+    CRYPTO_SHA256_RSA_PKCS(new ServiceDesc[]
+        { sdA("Signature", "SHA256withRSA",
+              "com.oracle.security.ucrypto.NativeRSASignature$SHA256")
+        }),
+    CRYPTO_SHA384_RSA_PKCS(new ServiceDesc[]
+        { sdA("Signature", "SHA384withRSA",
+              "com.oracle.security.ucrypto.NativeRSASignature$SHA384")
+        }),
+    CRYPTO_SHA512_RSA_PKCS(new ServiceDesc[]
+        { sdA("Signature", "SHA512withRSA",
+             "com.oracle.security.ucrypto.NativeRSASignature$SHA512")
+        }),
+
+    CRYPTO_MD5(new ServiceDesc[]
+        { sd("MessageDigest", "MD5", "com.oracle.security.ucrypto.NativeDigest$MD5")
+        }),
+    CRYPTO_SHA1(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA-1",
+              "com.oracle.security.ucrypto.NativeDigest$SHA1")
+        }),
+    CRYPTO_SHA224(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA-224",
+              "com.oracle.security.ucrypto.NativeDigest$SHA224")
+        }),
+    CRYPTO_SHA256(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA-256",
+              "com.oracle.security.ucrypto.NativeDigest$SHA256")
+        }),
+    CRYPTO_SHA384(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA-384",
+              "com.oracle.security.ucrypto.NativeDigest$SHA384")
+        }),
+    CRYPTO_SHA512(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA-512",
+              "com.oracle.security.ucrypto.NativeDigest$SHA512")
+        }),
+    CRYPTO_SHA3_224(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA3-224",
+              "com.oracle.security.ucrypto.NativeDigest$SHA3_224")
+        }),
+    CRYPTO_SHA3_256(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA3-256",
+              "com.oracle.security.ucrypto.NativeDigest$SHA3_256")
+        }),
+    CRYPTO_SHA3_384(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA3-384",
+              "com.oracle.security.ucrypto.NativeDigest$SHA3_384")
+        }),
+    CRYPTO_SHA3_512(new ServiceDesc[]
+        { sdA("MessageDigest", "SHA3-512",
+              "com.oracle.security.ucrypto.NativeDigest$SHA3_512")
+        });
+
+    private int mech = 0;
+    private final ServiceDesc[] serviceDescs;
+
+    private static ServiceDesc sd(String type, String algo, String cn) {
+        return new ServiceDesc(type, algo, cn, null);
+    }
+
+    private static ServiceDesc sd(String type, String algo, String cn,
+            List<String> aliases) {
+        return new ServiceDesc(type, algo, cn, aliases);
+    }
+
+    private static ServiceDesc sdA(String type, String algo, String cn) {
+        return new ServiceDesc(type, algo, cn, getAliases(algo));
+    }
+
+    UcryptoMech(ServiceDesc[] serviceDescs) {
+        this.serviceDescs = serviceDescs;
+    }
+
+    public void setValue(int nativeMechValue) {
+        this.mech = nativeMechValue;
+    }
+
+    public int value() { return mech; }
+    public ServiceDesc[] getServiceDescriptions() { return serviceDescs; }
+}
diff -ur -N /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoProvider.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoProvider.java
--- /tmp/a/solaris/classes/com/oracle/security/ucrypto/UcryptoProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/UcryptoProvider.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,256 @@
+/*
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.security.ucrypto;
+
+import java.io.IOException;
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.util.*;
+import java.security.*;
+import static sun.security.util.SecurityConstants.PROVIDER_VER;
+
+/**
+ * OracleUcrypto provider main class.
+ *
+ * @since 9
+ */
+public final class UcryptoProvider extends Provider {
+
+    private static final long serialVersionUID = 351251234302833L;
+
+    private static boolean DEBUG = false;
+    private static HashMap<String, ServiceDesc> provProp = null;
+    private static String defConfigName = "";
+
+    static {
+        try {
+            // cannot use LoadLibraryAction because that would make the native
+            // library available to the bootclassloader, but we run in the
+            // platform classloader.
+            provProp = AccessController.doPrivileged
+                (new PrivilegedAction<>() {
+                    @Override
+                    public HashMap<String, ServiceDesc> run() {
+                        String osname = System.getProperty("os.name");
+                        if (osname.startsWith("SunOS")) {
+                            try {
+                                DEBUG = Boolean.parseBoolean(System.getProperty("com.oracle.security.ucrypto.debug"));
+                                String javaHome = System.getProperty("java.home");
+                                String sep = System.getProperty("file.separator");
+                                defConfigName = javaHome + sep + "conf" + sep + "security" + sep +
+                                    "ucrypto-solaris.cfg";
+                                System.loadLibrary("j2ucrypto");
+                                return new HashMap<>();
+                            } catch (Error err) {
+                                if (DEBUG) err.printStackTrace();
+                            } catch (SecurityException se) {
+                                if (DEBUG) se.printStackTrace();
+                            }
+                        }
+                        return null;
+                    }
+                });
+            if (provProp != null) {
+                boolean[] result = loadLibraries();
+                if (result.length == 2) {
+                    // true when libsoftcrypto or libucrypto(S12) has been successfully loaded
+                    if (result[1]) {
+                        String supportedMechs = getMechList();
+                        debug("Prov: supported mechs = " + supportedMechs);
+                        StringTokenizer st = new StringTokenizer(supportedMechs, ":,;");
+                        // format: numOfSupportedMechs:[mechName,mechValue;]+
+                        // skip the first one which is numberOfSupportedMechs
+                        st.nextToken();
+                        while (st.hasMoreTokens()) {
+                            String mechName = st.nextToken();
+                            int nativeMechVal = Integer.parseInt(st.nextToken());
+                            try {
+                                UcryptoMech m = Enum.valueOf(UcryptoMech.class, mechName);
+                                m.setValue(nativeMechVal);
+                                ServiceDesc[] services = m.getServiceDescriptions();
+                                // defined in UcryptoMech as unsupported
+                                if (services == null || services.length == 0) {
+                                    debug("Skip Unsupported Algorithm: " + mechName);
+                                    continue;
+                                }
+                                for (int p = 0; p < services.length; p++) {
+                                    ServiceDesc entry = services[p];
+                                    provProp.put(entry.getType() + "." + entry.getAlgorithm(),
+                                                 entry);
+                                }
+                            } catch (IllegalArgumentException iae) {
+                                // not defined in UcryptoMech
+                                debug("Skip Unrecognized Algorithm: " + mechName);
+                            }
+                        }
+                        // NOTE: GCM support is only available since jdk 7
+                        provProp.put("AlgorithmParameters.GCM",
+                                     sd("AlgorithmParameters", "GCM",
+                                        "com.oracle.security.ucrypto.GCMParameters"));
+                    }
+                    // true when libmd is needed and has been successfully loaded
+                    if (result[0]) {
+                        for (LibMDMech m : LibMDMech.values()) {
+                            ServiceDesc[] services = m.getServiceDescriptions();
+                            for (ServiceDesc entry : services) {
+                                String sKey = entry.getType() + "." + entry.getAlgorithm();
+                                //  only register if none has been registered
+                                provProp.putIfAbsent(sKey, entry);
+                            }
+                        }
+                    };
+                } else {
+                    debug("Prov: unexpected ucrypto library loading error, got " + result.length);
+                }
+            }
+        } catch (AccessControlException ace) {
+            if (DEBUG) ace.printStackTrace();
+            // disable Ucrypto provider
+            provProp = null;
+        }
+    }
+
+    private static ServiceDesc sd(String type, String algo, String cn) {
+        return new ServiceDesc(type, algo, cn, null);
+    }
+
+    private static final class ProviderService extends Provider.Service {
+        ProviderService(Provider p, ServiceDesc sd) {
+            super(p, sd.getType(), sd.getAlgorithm(), sd.getClassName(),
+                  sd.getAliases(), null);
+        }
+
+        @SuppressWarnings("deprecation")
+        @Override
+        public Object newInstance(Object ctrParamObj)
+            throws NoSuchAlgorithmException {
+            String type = getType();
+            if (ctrParamObj != null) {
+                throw new InvalidParameterException
+                    ("constructorParameter not used with " + type + " engines");
+            }
+            String algo = getAlgorithm();
+            try {
+                if (type.equals("Cipher")) {
+                    int keySize = -1;
+                    if (algo.charAt(3) == '_') {
+                        keySize = Integer.parseInt(algo.substring(4, 7))/8;
+                    }
+                    String implClass = getClassName();
+                    Class<?> clz = Class.forName(implClass);
+                    if (keySize != -1) {
+                        Constructor<?> ctr = clz.getConstructor(int.class);
+                        return ctr.newInstance(keySize);
+                    } else {
+                        return clz.newInstance();
+                    }
+                } else if (type.equals("Signature") || type.equals("MessageDigest")) {
+                    String implClass = getClassName();
+                    Class<?> clz = Class.forName(implClass);
+                    return clz.newInstance();
+                } else if (type.equals("AlgorithmParameters")) {
+                    if (algo.equals("GCM")) {
+                        return new GCMParameters();
+                    }
+                }
+            } catch (Exception ex) {
+                throw new NoSuchAlgorithmException("Error constructing " +
+                    type + " for " + algo + " using OracleUcrypto", ex);
+            }
+            throw new ProviderException("No impl for " + algo +
+                " " + type);
+        }
+    }
+
+    static Provider provider = null;
+    private static native boolean[] loadLibraries();
+    private static native String getMechList();
+
+    static void debug(String msg) {
+        if (DEBUG) {
+            System.out.println("UCrypto/" + msg);
+        }
+    }
+
+    public UcryptoProvider() {
+        super("OracleUcrypto", PROVIDER_VER, "Provider using Oracle Ucrypto API");
+
+        AccessController.doPrivileged(new PrivilegedAction<>() {
+            public Void run() {
+                init(defConfigName);
+                return null;
+            }
+        });
+        if (provider == null) provider = this;
+    }
+
+    private void init(final String configName) {
+        if (provProp != null) {
+            debug("Prov: configuration file " + configName);
+            Config c;
+            try {
+                c = new Config(configName);
+            } catch (Exception ex) {
+                throw new UcryptoException("Error parsing Config", ex);
+            }
+
+            String[] disabledServices = c.getDisabledServices();
+            for (String ds : disabledServices) {
+                if (provProp.remove(ds) != null) {
+                    debug("Prov: remove config-disabled service " + ds);
+                } else {
+                    debug("Prov: ignore unsupported service " + ds);
+                }
+            }
+
+            for (ServiceDesc s: provProp.values()) {
+                debug("Prov: add service for " + s);
+                putService(new ProviderService(this, s));
+            }
+        }
+    }
+
+    @Override
+    public Provider configure(String configArg) throws InvalidParameterException {
+        try {
+            init(configArg);
+        } catch (UcryptoException ue) {
+            InvalidParameterException ipe =
+                    new InvalidParameterException("Error using " + configArg);
+            ipe.initCause(ue.getCause());
+            throw ipe;
+        }
+        return this;
+    }
+
+    public boolean equals(Object obj) {
+        return this == obj;
+    }
+
+    public int hashCode() {
+        return System.identityHashCode(this);
+    }
+}
diff -ur -N /tmp/a/solaris/classes/module-info.java jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/module-info.java
--- /tmp/a/solaris/classes/module-info.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/classes/module-info.java	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * Provides the implementation of the OracleUCrypto security provider.
+ *
+ * @provides java.security.Provider
+ * @moduleGraph
+ * @since 9
+ * @deprecated This module is deprecated and subject to removal in a future
+ *    version of the JDK. See JEP 362 for more information.
+ */
+@Deprecated(since="14", forRemoval=true)
+module jdk.crypto.ucrypto {
+    provides java.security.Provider with com.oracle.security.ucrypto.UcryptoProvider;
+}
+
diff -ur -N /tmp/a/solaris/conf/security/ucrypto-solaris.cfg jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/conf/security/ucrypto-solaris.cfg
--- /tmp/a/solaris/conf/security/ucrypto-solaris.cfg	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/conf/security/ucrypto-solaris.cfg	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Configuration file for the OracleUcrypto provider
+#
+disabledServices = {
+}
+
diff -ur -N /tmp/a/solaris/native/libj2ucrypto/nativeCrypto.c jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCrypto.c
--- /tmp/a/solaris/native/libj2ucrypto/nativeCrypto.c	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCrypto.c	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,1337 @@
+/*
+ * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <jni.h>
+#include "jni_util.h"
+#include "nativeCrypto.h"
+#include "nativeFunc.h"
+#include "com_oracle_security_ucrypto_NativeCipher.h"
+#include "com_oracle_security_ucrypto_NativeDigest.h"
+#include "com_oracle_security_ucrypto_NativeKey.h"
+#include "com_oracle_security_ucrypto_NativeKey.h"
+#include "com_oracle_security_ucrypto_NativeRSACipher.h"
+#include "com_oracle_security_ucrypto_NativeRSASignature.h"
+#include "com_oracle_security_ucrypto_UcryptoProvider.h"
+
+/*
+ * Dumps out byte array in hex with and name and length info
+ */
+void printError(char* header, int mech, int rv) {
+  if (mech != -1) {
+    printf("%s, mech = %d, rv = 0x%0x\n", header, mech, rv);
+  } else {
+    printf("%s, rv = 0x%0x\n", header, rv);
+  }
+  if (*ftab->ucryptoStrerror != NULL) {
+    char * reason = (*ftab->ucryptoStrerror)(rv);
+    printf("\tcause = %s\n", reason);
+    free(reason);
+  }
+}
+
+/*
+ * Dumps out byte array in hex with and name and length info
+ */
+void printBytes(char* header, unsigned char* bytes, int len) {
+  int i;
+
+  printf("%s", header);
+  printf("len=%d {", len);
+  for (i = 0; i < len; i++) {
+    if (i > 0) printf(":");
+    printf("%02X", bytes[i]);
+  }
+  printf("}\n");
+}
+
+/*
+ * Throws java.lang.OutOfMemoryError
+ */
+void throwOutOfMemoryError(JNIEnv *env, const char *msg)
+{
+  jclass jExClass = (*env)->FindClass(env, "java/lang/OutOfMemoryError");
+  if (jExClass != 0) /* Otherwise an exception has already been thrown */ {
+    (*env)->ThrowNew(env, jExClass, msg);
+  }
+  /* free the local ref */
+  (*env)->DeleteLocalRef(env, jExClass);
+}
+
+/*
+ * De-allocates all memory associated with crypto_ctx_t
+ */
+void freeContext(crypto_ctx_t *context) {
+  if (ftab->ucryptoFreeContext != NULL) {
+    (*ftab->ucryptoFreeContext)(context);
+  }
+  free(context);
+}
+
+JNIEXPORT jint JNICALL DEF_JNI_OnLoad(JavaVM *vm, void *reserved) {
+    return JNI_VERSION_1_4;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_UcryptoProvider
+ * Method:    loadLibraries
+ * Signature: ()[Z
+ */
+JNIEXPORT jbooleanArray JNICALL Java_com_oracle_security_ucrypto_UcryptoProvider_loadLibraries
+(JNIEnv *env, jclass jcls) {
+  jbooleanArray jResult;
+  jboolean *result;
+  jResult = (*env)->NewBooleanArray(env, 2);
+
+  if (jResult != NULL) {
+    result = loadNative();
+    (*env)->SetBooleanArrayRegion(env, jResult, 0, 2, result);
+    free(result);
+  }
+  return jResult;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_UcryptoProvider
+ * Method:    getMechList
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_com_oracle_security_ucrypto_UcryptoProvider_getMechList
+(JNIEnv *env, jclass jcls) {
+  jstring jResult;
+  char* result;
+  int length;
+
+  jResult = NULL;
+  if (ftab->ucryptoVersion != NULL && ftab->ucryptoGetMechList != NULL) {
+      length = (*ftab->ucryptoGetMechList)(NULL);
+      if (J2UC_DEBUG) printf("mech list length: %d\n", length);
+      result = malloc(length);
+      if (result == NULL) {
+        throwOutOfMemoryError(env, NULL);
+        return NULL;
+      }
+      length = (*ftab->ucryptoGetMechList)(result);
+      if (J2UC_DEBUG) printf("mech list: %s\n", result);
+      jResult = (*env)->NewStringUTF(env, result);
+      free(result);
+  } else {
+      // version 0 on Solaris 10
+      result = "CRYPTO_AES_ECB,CRYPTO_AES_CBC,CRYPTO_AES_CFB128,";
+      jResult = (*env)->NewStringUTF(env, result);
+  }
+  return jResult;
+}
+
+/*
+ * Utility function for throwing a UcryptoException when rv is not CRYPTO_OK(0)
+ */
+void throwUCExceptionUsingRV(JNIEnv *env, int rv) {
+  jclass jExClass;
+  jmethodID jConstructor;
+  jthrowable jException;
+
+  if ((*env)->ExceptionCheck(env)) return;
+
+  jExClass = (*env)->FindClass(env, "com/oracle/security/ucrypto/UcryptoException");
+  /* if jExClass is NULL, an exception has already been thrown */
+  if (jExClass != NULL) {
+    jConstructor = (*env)->GetMethodID(env, jExClass, "<init>", "(I)V");
+    if (jConstructor != NULL) {
+      jException = (jthrowable) (*env)->NewObject(env, jExClass, jConstructor, rv);
+      if (jException != NULL) {
+        (*env)->Throw(env, jException);
+      }
+    }
+  }
+  /* free the local ref */
+  (*env)->DeleteLocalRef(env, jExClass);
+}
+
+/*
+ * Utility function for duplicating a byte array from jbyteArray
+ * If anything went wrong, no memory will be allocated.
+ * NOTE: caller is responsible for freeing the allocated memory
+ * once this method returned successfully.
+ */
+jbyte* getBytes(JNIEnv *env, jbyteArray bytes, int offset, int len) {
+  jbyte* result = NULL;
+
+  if (!(*env)->ExceptionCheck(env)) {
+    result = (jbyte*) calloc(len, sizeof(char));
+    if (result == NULL) {
+      throwOutOfMemoryError(env, NULL);
+      return NULL;
+    }
+    (*env)->GetByteArrayRegion(env, bytes, offset, len, result);
+    if ((*env)->ExceptionCheck(env)) {
+        // free allocated memory if error occurred
+        free(result);
+        return NULL;
+    }
+  }
+  return result;
+}
+
+
+int
+CipherInit(crypto_ctx_t *context, int encrypt, ucrypto_mech_t mech,
+           unsigned char *jKey, int jKeyLen, unsigned char *jIv, int jIvLen,
+           int tagLen, unsigned char *jAad, int jAadLen)
+
+{
+  int rv = 0;
+  void *iv;
+  size_t ivLen;
+
+  if (J2UC_DEBUG) printf("CipherInit: mech %i, key %i(%i), iv %i(%i) tagLen %i, aad %i(%i)\n",
+                    mech, jKey, jKeyLen, jIv, jIvLen, tagLen, jAad, jAadLen);
+  if (mech == CRYPTO_AES_CTR) {
+    ivLen = sizeof(CK_AES_CTR_PARAMS);
+    iv = (CK_AES_CTR_PARAMS*) malloc(ivLen);
+    if (iv == NULL) return -1;
+
+    ((CK_AES_CTR_PARAMS*)iv)->ulCounterBits = 32;
+    memcpy(((CK_AES_CTR_PARAMS*)iv)->cb, jIv, 16);
+  } else if (mech == CRYPTO_AES_GCM) {
+    ivLen = sizeof(CK_AES_GCM_PARAMS);
+    iv = (CK_AES_GCM_PARAMS*) malloc(ivLen);
+    if (iv == NULL) return -1;
+
+    ((CK_AES_GCM_PARAMS*)iv)->pIv = (uchar_t *)jIv;
+    ((CK_AES_GCM_PARAMS*)iv)->ulIvLen = (ulong_t)jIvLen;
+    ((CK_AES_GCM_PARAMS*)iv)->ulIvBits = 96;
+    ((CK_AES_GCM_PARAMS*)iv)->pAAD = (uchar_t *)jAad;
+    ((CK_AES_GCM_PARAMS*)iv)->ulAADLen = (ulong_t)jAadLen;
+    ((CK_AES_GCM_PARAMS*)iv)->ulTagBits = (ulong_t)tagLen;
+  } else {
+    // normal bytes
+    iv = jIv;
+    ivLen = jIvLen;
+  }
+  if (encrypt) {
+    rv = (*ftab->ucryptoEncryptInit)(context, mech, jKey, (size_t)jKeyLen, iv, ivLen);
+    if (rv != 0 && J2UC_DEBUG) printError("ucryptoEncryptInit", mech, rv);
+  } else {
+    rv =(*ftab->ucryptoDecryptInit)(context, mech, jKey, (size_t)jKeyLen, iv, ivLen);
+    if (rv != 0 && J2UC_DEBUG) printError("ucryptoDecryptInit", mech, rv);
+  }
+
+  if (iv != jIv) {
+    if (mech == CRYPTO_AES_CTR) {
+      free((CK_AES_CTR_PARAMS*)iv);
+    } else {
+      free((CK_AES_GCM_PARAMS*)iv);
+    }
+  }
+
+  return rv;
+}
+
+int
+CipherUpdate(crypto_ctx_t *context, int encrypt, unsigned char *bufIn, int inOfs,
+             int inLen, unsigned char *bufOut, int outOfs, int *outLen)
+{
+  int rv = 0;
+  size_t outLength;
+
+  outLength = (size_t) *outLen;
+  if (J2UC_DEBUG) {
+    printf("CipherUpdate: Inofs %i, InLen %i, OutOfs %i, OutLen %i\n", inOfs, inLen, outOfs, *outLen);
+    printBytes("BufIn=", (unsigned char*)(bufIn+inOfs), inLen);
+  }
+  if (encrypt) {
+    rv = (*ftab->ucryptoEncryptUpdate)(context, (unsigned char*)(bufIn+inOfs), (size_t)inLen, (unsigned char*)(bufOut+outOfs), &outLength);
+    if (rv) {
+      if (J2UC_DEBUG) printError("ucryptoEncryptUpdate", -1, rv);
+    } else {
+      *outLen = (int)outLength;
+    }
+  } else {
+    rv = (*ftab->ucryptoDecryptUpdate)(context, (unsigned char*)(bufIn+inOfs), (size_t)inLen, (unsigned char*)(bufOut+outOfs), &outLength);
+    if (rv) {
+      if (J2UC_DEBUG) printError("ucryptoDecryptUpdate", -1, rv);
+    } else {
+      if (J2UC_DEBUG) printBytes("BufOut=", (unsigned char*)(bufOut+outOfs), outLength);
+      *outLen = (int)outLength;
+    }
+  }
+
+  return rv;
+}
+
+int
+CipherFinal(crypto_ctx_t *context, int encrypt, unsigned char *bufOut, int outOfs, int *outLen)
+{
+  int rv = 0;
+  size_t outLength;
+
+  outLength = (size_t)*outLen;
+
+  if (J2UC_DEBUG) printf("CipherFinal: OutOfs %i, outLen %i\n", outOfs, *outLen);
+  if (encrypt) {
+    rv = (*ftab->ucryptoEncryptFinal)(context, (unsigned char*)(bufOut+outOfs), &outLength);
+    if (rv) {
+      if (J2UC_DEBUG) printError("ucryptoDecryptFinal", -1, rv);
+    } else {
+      if (J2UC_DEBUG) printBytes("BufOut=", (unsigned char*)(bufOut+outOfs), outLength);
+      *outLen = (int)outLength;
+    }
+  } else {
+    rv = (*ftab->ucryptoDecryptFinal)(context, (unsigned char*)(bufOut+outOfs), &outLength);
+    if (rv) {
+      if (J2UC_DEBUG) printError("ucryptoDecryptFinal", -1, rv);
+    } else {
+      if (J2UC_DEBUG) printBytes("BufOut=", (unsigned char*)(bufOut+outOfs), outLength);
+      *outLen = (int)outLength;
+    }
+  }
+  return rv;
+}
+
+////////////////////////////////////////////////////////
+// SPECIAL ENTRIES FOR JVM JNI-BYPASSING OPTIMIZATION
+////////////////////////////////////////////////////////
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeInit(jint mech) {
+  crypto_ctx_t *context = NULL;
+  int rv;
+
+  context = malloc(sizeof(crypto_ctx_t));
+  if (context != NULL) {
+    rv = (*ftab->ucryptoDigestInit)(context, (ucrypto_mech_t) mech, NULL, 0);
+    if (rv) {
+      freeContext(context);
+      if (J2UC_DEBUG) printError("ucryptoDigestInit", mech, rv);
+      return 0L;
+    }
+  }
+  return (jlong) context;
+}
+
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeUpdate
+  (jint mech, jlong pContext, int notUsed, unsigned char* in, jint ofs, jint len) {
+  crypto_ctx_t *context;
+  jint rv = 0;
+
+  context = (crypto_ctx_t *) pContext;
+  rv = (*ftab->ucryptoDigestUpdate)(context, (const unsigned char*)(in + ofs),
+                                    (size_t) len);
+
+  if (rv) {
+    freeContext(context);
+    if (J2UC_DEBUG) printError("ucryptoDigestUpdate", mech, rv);
+  }
+
+  return -rv; // use negative value to indicate error
+}
+
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeDigest
+  (jint mech, jlong pContext, int notUsed, unsigned char* out, jint ofs, jint digestLen) {
+  crypto_ctx_t *context;
+  jint rv = 0;
+  size_t digest_len = digestLen;
+
+  context = (crypto_ctx_t *) pContext;
+  rv = (*ftab->ucryptoDigestFinal)(context, (unsigned char*)(out + ofs),
+                                   &digest_len);
+  if (rv) {
+    freeContext(context);
+    if (J2UC_DEBUG) printError("ucryptoDigestFinal", mech, rv);
+  }
+
+  return -rv; // use negative value to indicate error
+}
+
+JNIEXPORT void JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeFree
+  (jint mech, jlong pContext) {
+  crypto_ctx_t *context;
+
+  context = (crypto_ctx_t *) pContext;
+  freeContext(context);
+}
+
+// AES
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeCipher_nativeInit
+  (jint mech, jboolean encrypt, int keyLen, unsigned char* bufKey,
+   int ivLen, unsigned char* bufIv, jint tagLen, int aadLen, unsigned char* bufAad) {
+  crypto_ctx_t *context = NULL;
+  int rv;
+
+  context = malloc(sizeof(crypto_ctx_t));
+  if (context != NULL) {
+    rv = CipherInit(context, encrypt, (ucrypto_mech_t) mech, bufKey, keyLen,
+                    bufIv, ivLen, tagLen, bufAad, aadLen);
+    if (rv) {
+      freeContext(context);
+      return 0L;
+    }
+  }
+  return (jlong)context;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeCipher
+ * Method:    nativeUpdate
+ * Signature: (JZ[BII[BI)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeCipher_nativeUpdate
+  (jlong pContext, jboolean encrypt, int notUsed, jbyte* bufIn, jint inOfs, jint inLen,
+   int outCapacity, jbyte* bufOut, jint outOfs) {
+  crypto_ctx_t *context;
+  int rv = 0;
+  int outLen = outCapacity - outOfs; // recalculate the real out length
+
+  context = (crypto_ctx_t *) pContext;
+  rv = CipherUpdate(context, encrypt, (unsigned char*)bufIn, inOfs, inLen, (unsigned char*)bufOut, outOfs, &outLen);
+  if (rv) {
+    freeContext(context);
+    return -rv; // use negative value to indicate error!
+  }
+
+  return outLen;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeCipher
+ * Method:    nativeFinal
+ * Signature: (JZ[BI)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeCipher_nativeFinal
+  (jlong pContext, jboolean encrypt, int outLen, jbyte* out, jint outOfs) {
+  crypto_ctx_t *context;
+  int rv = 0;
+  unsigned char* bufOut = (unsigned char*) out;
+
+  context = (crypto_ctx_t *) pContext;
+  // Avoid null output buffer to workaround Solaris bug21481818 (fixed in S12)
+  if (bufOut == NULL) {
+    bufOut = (unsigned char*)(&outLen);
+    outLen = 0;
+  }
+  rv = CipherFinal(context, encrypt, bufOut, outOfs, &outLen);
+  freeContext(context);
+  if (rv) {
+     return -rv; // use negative value to indicate error!
+  }
+
+  return outLen;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigest
+ * Method:    nativeInit
+ * Signature: (I)J
+ */
+JNIEXPORT jlong JNICALL Java_com_oracle_security_ucrypto_NativeDigest_nativeInit
+  (JNIEnv *env, jclass jcls, jint mech) {
+  jlong result = JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeInit(mech);
+  if (result == NULL) {
+     throwOutOfMemoryError(env, NULL);
+  }
+  return result;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigest
+ * Method:    nativeUpdate
+ * Signature: (IJ[BII)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeDigest_nativeUpdate
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext, jbyteArray jIn, jint jOfs, jint jLen) {
+  unsigned char *bufIn;
+  jint rv = 0;
+
+
+  bufIn = (unsigned char *) getBytes(env, jIn, jOfs, jLen);
+  if (!(*env)->ExceptionCheck(env)) {
+    rv = JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeUpdate(mech, pContext, jLen, bufIn, 0, jLen);
+    free(bufIn);
+  }
+  return rv;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigest
+ * Method:    nativeDigest
+ * Signature: (IJ[BII)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeDigest_nativeDigest
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext, jbyteArray jOut, jint jOutOfs, jint digestLen) {
+  unsigned char *bufOut;
+  jint rv = 0;
+
+  bufOut = (unsigned char *) malloc(digestLen);
+  if (bufOut == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return 0;
+  }
+
+  rv = JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeDigest(mech, pContext, digestLen, bufOut, 0, digestLen);
+  if (rv == 0) {
+      (*env)->SetByteArrayRegion(env, jOut, jOutOfs, digestLen, (jbyte *) bufOut);
+  }
+  free(bufOut);
+  return rv;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigest
+ * Method:    nativeFree
+ * Signature: (IJ)V
+ */
+JNIEXPORT void JNICALL Java_com_oracle_security_ucrypto_NativeDigest_nativeFree
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext) {
+  JavaCritical_com_oracle_security_ucrypto_NativeDigest_nativeFree(mech, pContext);
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeCipher
+ * Method:    nativeInit
+ * Signature: (IZ[B[BI[B)J
+ */
+JNIEXPORT jlong JNICALL Java_com_oracle_security_ucrypto_NativeCipher_nativeInit
+(JNIEnv *env, jclass jcls, jint mech, jboolean encrypt, jbyteArray jKey,
+ jbyteArray jIv, jint tagLen, jbyteArray jAad) {
+
+  crypto_ctx_t *context;
+  unsigned char *bufKey;
+  unsigned char *bufIv;
+  unsigned char *bufAad;
+  int keyLen, ivLen, aadLen, rv = 0;
+  jlong result = 0L;
+
+  bufKey = bufIv = bufAad = NULL;
+  keyLen = ivLen = aadLen = 0;
+  context = malloc(sizeof(crypto_ctx_t));
+  if (context == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return 0L;
+  }
+
+  // jKey MUST NOT BE NULL;
+  keyLen = (*env)->GetArrayLength(env, jKey);
+  bufKey = (unsigned char *) (*env)->GetByteArrayElements(env, jKey, NULL);
+  if (bufKey == NULL) {
+    goto cleanup;
+  }
+
+  if (jIv != NULL) {
+    ivLen = (*env)->GetArrayLength(env, jIv);
+    bufIv = (unsigned char *) (*env)->GetByteArrayElements(env, jIv, NULL);
+    if (bufIv == NULL) {
+      goto cleanup;
+    }
+  }
+
+  if (jAad != NULL) {
+    aadLen = (*env)->GetArrayLength(env, jAad);
+    bufAad = (unsigned char *) (*env)->GetByteArrayElements(env, jAad, NULL);
+    if (bufAad == NULL) {
+      goto cleanup;
+    }
+  }
+
+  rv = CipherInit(context, encrypt, mech, bufKey, keyLen, bufIv, ivLen, tagLen, bufAad, aadLen);
+  if (rv != 0) {
+    throwUCExceptionUsingRV(env, rv);
+  } else {
+     result = (jlong) context;
+  }
+
+cleanup:
+  if ((result == 0L) && (context != NULL)) {
+    freeContext(context);
+  }
+  if (bufKey != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jKey, (jbyte *)bufKey, 0);
+  }
+  if (bufIv != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jIv, (jbyte *)bufIv, 0);
+  }
+  if (bufAad != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jAad, (jbyte *)bufAad, 0);
+  }
+
+  return result;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeCipher
+ * Method:    nativeUpdate
+ * Signature: (JZ[BII[BI)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeCipher_nativeUpdate
+  (JNIEnv *env, jclass jcls, jlong contextID, jboolean encrypt,
+    jbyteArray jIn, jint inOfs, jint inLen, jbyteArray jOut, jint outOfs) {
+  crypto_ctx_t *context;
+  unsigned char *bufIn;
+  unsigned char *bufOut;
+  int outLen, rv = 0;
+
+  context = (crypto_ctx_t *) contextID;
+  bufIn = (unsigned char *) getBytes(env, jIn, inOfs, inLen);
+  if ((*env)->ExceptionCheck(env)) {
+    return 0;
+  }
+
+  outLen = (*env)->GetArrayLength(env, jOut) - outOfs;
+  bufOut = calloc(outLen, sizeof(char));
+  if (bufOut == NULL) {
+    free(bufIn);
+    throwOutOfMemoryError(env, NULL);
+    return 0;
+  }
+
+  rv = CipherUpdate(context, encrypt, bufIn, 0, inLen, bufOut, 0, &outLen);
+  if (rv) {
+    freeContext(context);
+    free(bufIn);
+    free(bufOut);
+    return -rv;
+  } else {
+    (*env)->SetByteArrayRegion(env, jOut, outOfs, outLen, (jbyte *)bufOut);
+    free(bufIn);
+    free(bufOut);
+    return outLen;
+  }
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeCipher
+ * Method:    nativeFinal
+ * Signature: (JZ[BI)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeCipher_nativeFinal
+  (JNIEnv *env, jclass jCls, jlong contextID, jboolean encrypt,
+   jbyteArray out, jint outOfs) {
+  crypto_ctx_t *context;
+  unsigned char *bufIn;
+  unsigned char *bufOut;
+  int outLen, rv = 0;
+  jint rc;
+
+  context = (crypto_ctx_t *) contextID;
+
+  // out is null when nativeFinal() is called solely for resource clean up
+  if (out == NULL) {
+    // Avoid null output buffer to workaround Solaris bug21481818 (fixed in S12)
+    bufOut = (unsigned char *)(&outLen);
+    outLen = 0;
+  } else {
+    outLen = (*env)->GetArrayLength(env, out) - outOfs;
+    bufOut = calloc(outLen, sizeof(char));
+    if (bufOut == NULL) {
+      throwOutOfMemoryError(env, NULL);
+      return 0;
+    }
+  }
+  rv = CipherFinal(context, encrypt, bufOut, 0, &outLen);
+  if (rv) {
+    rc = -rv;
+  } else {
+    if (outLen > 0) {
+      (*env)->SetByteArrayRegion(env, out, outOfs, outLen, (jbyte *)bufOut);
+    }
+    rc = outLen;
+  }
+  free(context);
+  if (bufOut != (unsigned char *)(&outLen)) {
+    free(bufOut);
+  }
+  return rc;
+}
+
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeKey
+ * Method:    nativeFree
+ * Signature: (JI)V
+ */
+JNIEXPORT void JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeKey_nativeFree
+  (jlong id, jint numOfComponents) {
+  crypto_object_attribute_t* pKey;
+  int i;
+
+  pKey = (crypto_object_attribute_t*) id;
+  for (i = 0; i < numOfComponents; i++) {
+    free(pKey[i].oa_value);
+  }
+  free(pKey);
+}
+
+JNIEXPORT void JNICALL Java_com_oracle_security_ucrypto_NativeKey_nativeFree
+  (JNIEnv *env, jclass jCls, jlong id, jint numOfComponents) {
+  JavaCritical_com_oracle_security_ucrypto_NativeKey_nativeFree(id, numOfComponents);
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeKey_RSAPrivate
+ * Method:    nativeInit
+ * Signature: ([B[B)J
+ */
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeKey_00024RSAPrivate_nativeInit
+(int modLen, jbyte* jMod, int privLen, jbyte* jPriv) {
+
+  unsigned char *mod, *priv;
+  crypto_object_attribute_t* pKey = NULL;
+
+  pKey = calloc(2, sizeof(crypto_object_attribute_t));
+  if (pKey == NULL) {
+    return 0L;
+  }
+  mod = priv = NULL;
+  mod = malloc(modLen);
+  priv = malloc(privLen);
+  if (mod == NULL || priv == NULL) {
+    free(pKey);
+    free(mod);
+    free(priv);
+    return 0L;
+  } else {
+    memcpy(mod, jMod, modLen);
+    memcpy(priv, jPriv, privLen);
+  }
+
+  // NOTE: numOfComponents should be 2
+  pKey[0].oa_type = SUN_CKA_MODULUS;
+  pKey[0].oa_value = (char*) mod;
+  pKey[0].oa_value_len = (size_t) modLen;
+  pKey[1].oa_type = SUN_CKA_PRIVATE_EXPONENT;
+  pKey[1].oa_value = (char*) priv;
+  pKey[1].oa_value_len = (size_t) privLen;
+
+  return (jlong) pKey;
+}
+
+JNIEXPORT jlong JNICALL
+Java_com_oracle_security_ucrypto_NativeKey_00024RSAPrivate_nativeInit
+  (JNIEnv *env, jclass jCls, jbyteArray jMod, jbyteArray jPriv) {
+
+  int modLen, privLen;
+  jbyte *bufMod, *bufPriv;
+  crypto_object_attribute_t* pKey = NULL;
+
+  bufMod = bufPriv = NULL;
+
+  modLen = (*env)->GetArrayLength(env, jMod);
+  bufMod = getBytes(env, jMod, 0, modLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  privLen = (*env)->GetArrayLength(env, jPriv);
+  bufPriv = getBytes(env, jPriv, 0, privLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  // proceed if no error; otherwise free allocated memory
+  pKey = calloc(2, sizeof(crypto_object_attribute_t));
+  if (pKey == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    goto cleanup;
+  }
+
+  // NOTE: numOfComponents should be 2
+  pKey[0].oa_type = SUN_CKA_MODULUS;
+  pKey[0].oa_value = (char*) bufMod;
+  pKey[0].oa_value_len = (size_t) modLen;
+  pKey[1].oa_type = SUN_CKA_PRIVATE_EXPONENT;
+  pKey[1].oa_value = (char*) bufPriv;
+  pKey[1].oa_value_len = (size_t) privLen;
+  return (jlong) pKey;
+
+cleanup:
+  free(bufMod);
+  free(bufPriv);
+
+  return 0L;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeKey_RSAPrivateCrt
+ * Method:    nativeInit
+ * Signature: ([B[B[B[B[B[B[B[B)J
+ */
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeKey_00024RSAPrivateCrt_nativeInit
+(int modLen, jbyte* jMod, int pubLen, jbyte* jPub, int privLen, jbyte* jPriv,
+ int pLen, jbyte* jP, int qLen, jbyte* jQ, int expPLen, jbyte* jExpP,
+ int expQLen, jbyte* jExpQ, int crtCoeffLen, jbyte* jCrtCoeff) {
+
+  unsigned char *mod, *pub, *priv, *p, *q, *expP, *expQ, *crtCoeff;
+  crypto_object_attribute_t* pKey = NULL;
+
+  pKey = calloc(8, sizeof(crypto_object_attribute_t));
+  if (pKey == NULL) {
+    return 0L;
+  }
+  mod = pub = priv = p = q = expP = expQ = crtCoeff = NULL;
+  mod = malloc(modLen);
+  pub = malloc(pubLen);
+  priv = malloc(privLen);
+  p = malloc(pLen);
+  q = malloc(qLen);
+  expP = malloc(expPLen);
+  expQ = malloc(expQLen);
+  crtCoeff = malloc(crtCoeffLen);
+  if (mod == NULL || pub == NULL || priv == NULL || p == NULL ||
+      q == NULL || expP == NULL || expQ == NULL || crtCoeff == NULL) {
+    free(pKey);
+    free(mod);
+    free(pub);
+    free(priv);
+    free(p);
+    free(q);
+    free(expP);
+    free(expQ);
+    free(crtCoeff);
+    return 0L;
+  } else {
+    memcpy(mod, jMod, modLen);
+    memcpy(pub, jPub, pubLen);
+    memcpy(priv, jPriv, privLen);
+    memcpy(p, jP, pLen);
+    memcpy(q, jQ, qLen);
+    memcpy(expP, jExpP, expPLen);
+    memcpy(expQ, jExpQ, expQLen);
+    memcpy(crtCoeff, jCrtCoeff, crtCoeffLen);
+  }
+
+  // NOTE: numOfComponents should be 8
+  pKey[0].oa_type = SUN_CKA_MODULUS;
+  pKey[0].oa_value = (char*) mod;
+  pKey[0].oa_value_len = (size_t) modLen;
+  pKey[1].oa_type = SUN_CKA_PUBLIC_EXPONENT;
+  pKey[1].oa_value = (char*) pub;
+  pKey[1].oa_value_len = (size_t) pubLen;
+  pKey[2].oa_type = SUN_CKA_PRIVATE_EXPONENT;
+  pKey[2].oa_value = (char*) priv;
+  pKey[2].oa_value_len = (size_t) privLen;
+  pKey[3].oa_type = SUN_CKA_PRIME_1;
+  pKey[3].oa_value = (char*) p;
+  pKey[3].oa_value_len = (size_t) pLen;
+  pKey[4].oa_type = SUN_CKA_PRIME_2;
+  pKey[4].oa_value = (char*) q;
+  pKey[4].oa_value_len = (size_t) qLen;
+  pKey[5].oa_type = SUN_CKA_EXPONENT_1;
+  pKey[5].oa_value = (char*) expP;
+  pKey[5].oa_value_len = (size_t) expPLen;
+  pKey[6].oa_type = SUN_CKA_EXPONENT_2;
+  pKey[6].oa_value = (char*) expQ;
+  pKey[6].oa_value_len = (size_t) expQLen;
+  pKey[7].oa_type = SUN_CKA_COEFFICIENT;
+  pKey[7].oa_value = (char*) crtCoeff;
+  pKey[7].oa_value_len = (size_t) crtCoeffLen;
+
+  return (jlong) pKey;
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_com_oracle_security_ucrypto_NativeKey_00024RSAPrivateCrt_nativeInit
+  (JNIEnv *env, jclass jCls, jbyteArray jMod, jbyteArray jPub, jbyteArray jPriv,
+   jbyteArray jP, jbyteArray jQ, jbyteArray jExpP, jbyteArray jExpQ,
+   jbyteArray jCrtCoeff) {
+
+  int modLen, pubLen, privLen, pLen, qLen, expPLen, expQLen, crtCoeffLen;
+  jbyte *bufMod, *bufPub, *bufPriv, *bufP, *bufQ, *bufExpP, *bufExpQ, *bufCrtCoeff;
+  crypto_object_attribute_t* pKey = NULL;
+
+  bufMod = bufPub = bufPriv = bufP = bufQ = bufExpP = bufExpQ = bufCrtCoeff = NULL;
+
+  modLen = (*env)->GetArrayLength(env, jMod);
+  bufMod = getBytes(env, jMod, 0, modLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  pubLen = (*env)->GetArrayLength(env, jPub);
+  bufPub = getBytes(env, jPub, 0, pubLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  privLen = (*env)->GetArrayLength(env, jPriv);
+  bufPriv = getBytes(env, jPriv, 0, privLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  pLen = (*env)->GetArrayLength(env, jP);
+  bufP = getBytes(env, jP, 0, pLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  qLen = (*env)->GetArrayLength(env, jQ);
+  bufQ = getBytes(env, jQ, 0, qLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  expPLen = (*env)->GetArrayLength(env, jExpP);
+  bufExpP = getBytes(env, jExpP, 0, expPLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  expQLen = (*env)->GetArrayLength(env, jExpQ);
+  bufExpQ = getBytes(env, jExpQ, 0, expQLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  crtCoeffLen = (*env)->GetArrayLength(env, jCrtCoeff);
+  bufCrtCoeff = getBytes(env, jCrtCoeff, 0, crtCoeffLen);
+  if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+  // proceed if no error; otherwise free allocated memory
+  pKey = calloc(8, sizeof(crypto_object_attribute_t));
+  if (pKey == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    goto cleanup;
+  }
+
+  // NOTE: numOfComponents should be 8
+  pKey[0].oa_type = SUN_CKA_MODULUS;
+  pKey[0].oa_value = (char*) bufMod;
+  pKey[0].oa_value_len = (size_t) modLen;
+  pKey[1].oa_type = SUN_CKA_PUBLIC_EXPONENT;
+  pKey[1].oa_value = (char*) bufPub;
+  pKey[1].oa_value_len = (size_t) pubLen;
+  pKey[2].oa_type = SUN_CKA_PRIVATE_EXPONENT;
+  pKey[2].oa_value = (char*) bufPriv;
+  pKey[2].oa_value_len = (size_t) privLen;
+  pKey[3].oa_type = SUN_CKA_PRIME_1;
+  pKey[3].oa_value = (char*) bufP;
+  pKey[3].oa_value_len = (size_t) pLen;
+  pKey[4].oa_type = SUN_CKA_PRIME_2;
+  pKey[4].oa_value = (char*) bufQ;
+  pKey[4].oa_value_len = (size_t) qLen;
+  pKey[5].oa_type = SUN_CKA_EXPONENT_1;
+  pKey[5].oa_value = (char*) bufExpP;
+  pKey[5].oa_value_len = (size_t) expPLen;
+  pKey[6].oa_type = SUN_CKA_EXPONENT_2;
+  pKey[6].oa_value = (char*) bufExpQ;
+  pKey[6].oa_value_len = (size_t) expQLen;
+  pKey[7].oa_type = SUN_CKA_COEFFICIENT;
+  pKey[7].oa_value = (char*) bufCrtCoeff;
+  pKey[7].oa_value_len = (size_t) crtCoeffLen;
+  return (jlong) pKey;
+
+cleanup:
+  free(bufMod);
+  free(bufPub);
+  free(bufPriv);
+  free(bufP);
+  free(bufQ);
+  free(bufExpP);
+  free(bufExpQ);
+  free(bufCrtCoeff);
+
+  return 0L;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeKey_RSAPublic
+ * Method:    nativeInit
+ * Signature: ([B[B)J
+ */
+
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeKey_00024RSAPublic_nativeInit
+(int modLen, jbyte* jMod, int pubLen, jbyte* jPub) {
+  unsigned char *mod, *pub;
+  crypto_object_attribute_t* pKey = NULL;
+
+  pKey = calloc(2, sizeof(crypto_object_attribute_t));
+  if (pKey == NULL) {
+    return 0L;
+  }
+  mod = pub = NULL;
+  mod = malloc(modLen);
+  pub = malloc(pubLen);
+  if (mod == NULL || pub == NULL) {
+    free(pKey);
+    free(mod);
+    free(pub);
+    return 0L;
+  } else {
+    memcpy(mod, jMod, modLen);
+    memcpy(pub, jPub, pubLen);
+  }
+
+  if (J2UC_DEBUG) {
+    printf("RSAPublicKey.nativeInit: keyValue=%ld, keyLen=2\n", pKey);
+    printBytes("\tmod: ", (unsigned char*) mod, modLen);
+    printBytes("\tpubExp: ", (unsigned char*) pub, pubLen);
+  }
+
+  pKey[0].oa_type = SUN_CKA_MODULUS;
+  pKey[0].oa_value = (char*) mod;
+  pKey[0].oa_value_len = (size_t) modLen;
+  pKey[1].oa_type = SUN_CKA_PUBLIC_EXPONENT;
+  pKey[1].oa_value = (char*) pub;
+  pKey[1].oa_value_len = (size_t) pubLen;
+
+  return (jlong) pKey;
+}
+
+JNIEXPORT jlong JNICALL
+Java_com_oracle_security_ucrypto_NativeKey_00024RSAPublic_nativeInit
+(JNIEnv *env, jclass jCls, jbyteArray jMod, jbyteArray jPub) {
+  int modLen, pubLen;
+  jbyte *bufMod, *bufPub;
+  crypto_object_attribute_t* pKey = NULL;
+
+  bufMod = bufPub = NULL;
+
+  modLen = (*env)->GetArrayLength(env, jMod);
+  bufMod = getBytes(env, jMod, 0, modLen);
+  if ((*env)->ExceptionCheck(env)) {
+    return 0L;
+  }
+
+  pubLen = (*env)->GetArrayLength(env, jPub);
+  bufPub = getBytes(env, jPub, 0, pubLen);
+  if ((*env)->ExceptionCheck(env)) {
+    free(bufMod);
+    return 0L;
+  }
+
+  // proceed if no error; otherwise free allocated memory
+  pKey = calloc(2, sizeof(crypto_object_attribute_t));
+  if (pKey != NULL) {
+    // NOTE: numOfComponents should be 2
+    pKey[0].oa_type = SUN_CKA_MODULUS;
+    pKey[0].oa_value = (char*) bufMod;
+    pKey[0].oa_value_len = (size_t) modLen;
+    pKey[1].oa_type = SUN_CKA_PUBLIC_EXPONENT;
+    pKey[1].oa_value = (char*) bufPub;
+    pKey[1].oa_value_len = (size_t) pubLen;
+    return (jlong) pKey;
+  } else {
+    free(bufMod);
+    free(bufPub);
+    throwOutOfMemoryError(env, NULL);
+    return 0L;
+  }
+}
+
+////////////////////////
+// NativeRSASignature
+////////////////////////
+
+int
+SignatureInit(crypto_ctx_t *context, jint mechVal, jboolean sign,
+              uchar_t *pKey, size_t keyLength) {
+  ucrypto_mech_t mech;
+  int rv = 0;
+
+  mech = (ucrypto_mech_t) mechVal;
+
+  if (sign) {
+    rv = (*ftab->ucryptoSignInit)(context, mech, pKey, keyLength,
+                                  NULL, 0);
+  } else {
+    rv = (*ftab->ucryptoVerifyInit)(context, mech, pKey, keyLength,
+                                    NULL, 0);
+  }
+  if (J2UC_DEBUG) {
+    printf("SignatureInit: context=%ld, mech=%d, sign=%d, keyValue=%ld, keyLength=%d\n",
+           context, mech, sign, pKey, keyLength);
+    printError("SignatureInit", mech, rv);
+  }
+  return rv;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeRSASignature
+ * Method:    nativeInit
+ * Signature: (IZJI[B)J
+ */
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeInit
+(jint mech, jboolean sign, jlong jKey, jint keyLength) {
+  crypto_ctx_t *context;
+  int rv;
+  uchar_t *pKey;
+
+  context = malloc(sizeof(crypto_ctx_t));
+  if (context != NULL) {
+    pKey = (uchar_t *) jKey;
+    rv = SignatureInit(context, mech, sign, pKey, (size_t)keyLength);
+    if (rv) {
+      freeContext(context);
+      return 0L;
+    }
+  }
+  return (jlong)context;
+}
+
+JNIEXPORT jlong JNICALL Java_com_oracle_security_ucrypto_NativeRSASignature_nativeInit
+(JNIEnv *env, jclass jCls, jint mech, jboolean sign, jlong jKey, jint keyLength) {
+  crypto_ctx_t *context;
+  int rv = 0;
+  uchar_t *pKey;
+
+  context = malloc(sizeof(crypto_ctx_t));
+  if (context == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return 0L;
+  }
+
+  pKey = (uchar_t *) jKey;
+  rv = SignatureInit(context, mech, sign, pKey, (size_t)keyLength);
+  if (rv) {
+    freeContext(context);
+    throwUCExceptionUsingRV(env, rv);
+    return 0L;
+  }
+
+  return (jlong)context;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeRSASignature
+ * Method:    nativeUpdate
+ * Signature: (JZ[BII)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZ_3BII
+(jlong pCtxt, jboolean sign, int notUsed, jbyte* jIn, jint jInOfs, jint jInLen) {
+  crypto_ctx_t *context;
+  int rv = 0;
+
+  context = (crypto_ctx_t *) pCtxt;
+  if (J2UC_DEBUG) {
+    printf("NativeRSASignature.nativeUpdate: context=%ld, sign=%d, jIn=%ld, jInOfs=%d, jInLen=%d\n",
+           context, sign, jIn, jInOfs, jInLen);
+  }
+  if (sign) {
+    rv = (*ftab->ucryptoSignUpdate)(context, (uchar_t *) (jIn + jInOfs), (size_t) jInLen);
+  } else {
+    rv = (*ftab->ucryptoVerifyUpdate)(context, (uchar_t *) (jIn + jInOfs), (size_t) jInLen);
+  }
+  if (rv) {
+    freeContext(context);
+    if (J2UC_DEBUG) printError("NativeRSASignature.nativeUpdate", -1, rv);
+    return -rv; // use negative value to indicate error!
+  }
+
+  return 0;
+}
+
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZ_3BII
+(JNIEnv *env, jclass jCls, jlong pCtxt, jboolean sign, jbyteArray jIn, jint inOfs, jint inLen) {
+  int rv = 0;
+  jbyte* bufIn;
+
+  bufIn = getBytes(env, jIn, inOfs, inLen);
+  if ((*env)->ExceptionCheck(env)) {
+    return -1; // use negative value to indicate error!
+  }
+
+  if (J2UC_DEBUG) printBytes("Update w/ data: ", (unsigned char*)bufIn, (size_t) inLen);
+
+  rv = JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZ_3BII
+    (pCtxt, sign, inLen, bufIn, 0, inLen);
+
+  free(bufIn);
+  return rv;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeRSASignature
+ * Method:    nativeUpdate
+ * Signature: (JZJI)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZJI
+(jlong pCtxt, jboolean sign, jlong inAddr, jint inLen) {
+
+  return JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZ_3BII
+    (pCtxt, sign, inLen, (jbyte*)inAddr, 0, inLen);
+}
+
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZJI
+(JNIEnv *env, jclass jCls, jlong pCtxt, jboolean sign, jlong inAddr, jint inLen) {
+
+  return JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeUpdate__JZ_3BII
+    (pCtxt, sign, inLen, (jbyte*)inAddr, 0, inLen);
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeRSASignature
+ * Method:    nativeFinal
+ * Signature: (JZ[BII)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeFinal
+(jlong pCtxt, jboolean sign, int notUsed, jbyte* bufSig, jint sigOfs, jint jSigLen) {
+
+  crypto_ctx_t *context;
+  int rv = 0;
+  size_t sigLength = (size_t) jSigLen;
+
+  context = (crypto_ctx_t *) pCtxt;
+  if (J2UC_DEBUG) {
+      printf("NativeRSASignature.nativeFinal: context=%ld, sign=%d, bufSig=%ld, sigOfs=%d, sigLen=%d\n",
+             context, sign, bufSig, sigOfs, jSigLen);
+      printBytes("Before: SigBytes ", (unsigned char*) (bufSig + sigOfs), jSigLen);
+  }
+  if (sign) {
+    rv = (*ftab->ucryptoSignFinal)(context, (uchar_t *) (bufSig + sigOfs), &sigLength);
+  } else {
+    rv = (*ftab->ucryptoVerifyFinal)(context, (uchar_t *) (bufSig + sigOfs), &sigLength);
+  }
+
+  freeContext(context);
+  if (rv) {
+    if (J2UC_DEBUG) {
+      printError("NativeRSASignature.nativeFinal", -1, rv);
+      if (sigLength != jSigLen) {
+        printf("NativeRSASignature.nativeFinal out sig len=%d\n", sigLength);
+      }
+      if (sign) {
+        printBytes("After: SigBytes ", (unsigned char*) (bufSig + sigOfs), jSigLen);
+      }
+    }
+    return -rv;
+  } else return 0;
+}
+
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeRSASignature_nativeFinal
+(JNIEnv *env, jclass jCls, jlong pCtxt, jboolean sign, jbyteArray jSig, jint jSigOfs, jint jSigLen) {
+  int rv = 0;
+  jbyte* bufSig = NULL;
+
+  if (jSigLen != 0) {
+    bufSig = calloc(jSigLen, sizeof(char));
+    if (bufSig == NULL) {
+      throwOutOfMemoryError(env, NULL);
+      return 0;
+    }
+    if (!sign) {
+      // need to copy over the to-be-verified signature bytes
+      (*env)->GetByteArrayRegion(env, jSig, jSigOfs, jSigLen, (jbyte *)bufSig);
+    }
+  }
+
+  if (!(*env)->ExceptionCheck(env)) {
+    // Frees context + converts rv to negative if error occurred
+    rv = JavaCritical_com_oracle_security_ucrypto_NativeRSASignature_nativeFinal
+      (pCtxt, sign, jSigLen, bufSig, 0, jSigLen);
+
+    if (rv == 0 && sign) {
+      // need to copy the generated signature bytes to the java bytearray
+      (*env)->SetByteArrayRegion(env, jSig, jSigOfs, jSigLen, (jbyte *)bufSig);
+    }
+  } else {
+    // set rv to negative to indicate error
+    rv = -1;
+  }
+
+  free(bufSig);
+
+  return rv;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeRSACipher
+ * Method:    nativeAtomic
+ * Signature: (IZJI[BI[BII)I
+ */
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeRSACipher_nativeAtomic
+  (jint mech, jboolean encrypt, jlong keyValue, jint keyLength,
+   int notUsed1, jbyte* bufIn, jint jInLen,
+   int notUsed2, jbyte* bufOut, jint jOutOfs, jint jOutLen) {
+
+  uchar_t *pKey;
+  crypto_object_attribute_t* pKey2;
+  int rv = 0;
+  size_t outLength = (size_t) jOutLen;
+
+  pKey = (uchar_t *) keyValue;
+  if (J2UC_DEBUG) {
+    printf("NativeRSACipher.nativeAtomic: mech=%d, encrypt=%d, pKey=%ld, keyLength=%d\n",
+           mech, encrypt, pKey, keyLength);
+    printBytes("Before: in  = ", (unsigned char*) bufIn, jInLen);
+    printBytes("Before: out = ", (unsigned char*) (bufOut + jOutOfs), jOutLen);
+  }
+
+  if (encrypt) {
+    rv = (*ftab->ucryptoEncrypt)((ucrypto_mech_t)mech, pKey, (size_t)keyLength,
+      NULL, 0, (uchar_t *)bufIn, (size_t)jInLen,
+      (uchar_t *)(bufOut + jOutOfs), &outLength);
+  } else {
+    rv = (*ftab->ucryptoDecrypt)((ucrypto_mech_t)mech, pKey, (size_t)keyLength,
+      NULL, 0, (uchar_t *)bufIn, (size_t)jInLen,
+      (uchar_t *)(bufOut + jOutOfs), &outLength);
+  }
+  if (J2UC_DEBUG) {
+    printError("NativeRSACipher.nativeAtomic", mech, rv);
+    if (outLength != jOutLen) {
+      printf("NativeRSACipher.nativeAtomic out len=%d\n", outLength);
+    }
+    printBytes("After: ", (unsigned char*) (bufOut + jOutOfs), outLength);
+  }
+
+  if (rv) {
+    return -rv;
+  } else return outLength;
+}
+
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeRSACipher_nativeAtomic
+  (JNIEnv *env, jclass jCls, jint mech, jboolean encrypt,
+   jlong keyValue, jint keyLength, jbyteArray jIn, jint jInLen,
+   jbyteArray jOut, jint jOutOfs, jint jOutLen) {
+  int rv = 0;
+  jbyte *bufIn = NULL;
+  jbyte *bufOut = NULL;
+
+  if (jInLen != 0) {
+    bufIn = (*env)->GetByteArrayElements(env, jIn, NULL);
+    if (bufIn == NULL) {
+      return 0;
+    }
+  }
+  bufOut = calloc(jOutLen, sizeof(jbyte));
+  if (bufOut == NULL) {
+    (*env)->ReleaseByteArrayElements(env, jIn, bufIn, 0);
+    throwOutOfMemoryError(env, NULL);
+    return 0;
+  }
+
+  // rv: output length or error code (if negative)
+  rv = JavaCritical_com_oracle_security_ucrypto_NativeRSACipher_nativeAtomic
+    (mech, encrypt, keyValue, keyLength, jInLen, bufIn, jInLen,
+     jOutLen, bufOut, 0, jOutLen);
+
+  if (rv > 0) {
+    (*env)->SetByteArrayRegion(env, jOut, jOutOfs, rv, (jbyte *)bufOut);
+  }
+
+  if (bufIn != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jIn, bufIn, 0);
+  }
+  free(bufOut);
+  return rv;
+}
diff -ur -N /tmp/a/solaris/native/libj2ucrypto/nativeCrypto.h jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCrypto.h
--- /tmp/a/solaris/native/libj2ucrypto/nativeCrypto.h	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCrypto.h	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <libsoftcrypto.h> // redirects to libucrypto.h starting 11.3
+
+#ifndef _Included_com_oracle_security_ucrypto_NativeCrypto
+#define _Included_com_oracle_security_ucrypto_NativeCrypto
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// used by nativeCryptoMD.c
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5 1L
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1 2L
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA256
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA256 3L
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA224
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA224 4L
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA384
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA384 5L
+#undef com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA512
+#define com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA512 6L
+
+#define J2UC_DEBUG 0
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -ur -N /tmp/a/solaris/native/libj2ucrypto/nativeCryptoMD.c jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCryptoMD.c
--- /tmp/a/solaris/native/libj2ucrypto/nativeCryptoMD.c	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeCryptoMD.c	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <jni.h>
+#include "jni_util.h"
+#include "nativeCrypto.h"
+#include "nativeFunc.h"
+#include "com_oracle_security_ucrypto_NativeDigestMD.h"
+
+extern void throwOutOfMemoryError(JNIEnv *env, const char *msg);
+extern jbyte* getBytes(JNIEnv *env, jbyteArray bytes, int offset, int len);
+
+///////////////////////////////////////////////////////
+// SPECIAL ENTRIES FOR JVM JNI-BYPASSING OPTIMIZATION
+////////////////////////////////////////////////////////
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeInit(jint mech) {
+  void *pContext = NULL;
+
+  switch (mech) {
+  case com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1:
+    pContext = malloc(sizeof(SHA1_CTX));
+    if (pContext != NULL) {
+      (*ftab->sha1Init)((SHA1_CTX *)pContext);
+    }
+    break;
+  case com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5:
+    pContext = malloc(sizeof(MD5_CTX));
+    if (pContext != NULL) {
+      (*ftab->md5Init)((MD5_CTX *)pContext);
+    }
+    break;
+  case com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA256:
+    pContext = malloc(sizeof(SHA2_CTX));
+    if (pContext != NULL) {
+      (*ftab->sha2Init)(SHA256, (SHA2_CTX *)pContext);
+    }
+    break;
+  case com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA384:
+    pContext = malloc(sizeof(SHA2_CTX));
+    if (pContext != NULL) {
+      (*ftab->sha2Init)(SHA384, (SHA2_CTX *)pContext);
+    }
+    break;
+  case com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA512:
+    pContext = malloc(sizeof(SHA2_CTX));
+    if (pContext != NULL) {
+      (*ftab->sha2Init)(SHA512, (SHA2_CTX *)pContext);
+    }
+    break;
+  default:
+    if (J2UC_DEBUG) printf("ERROR: Unsupported mech %i\n", mech);
+  }
+  return (jlong) pContext;
+}
+
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeUpdate
+  (jint mech, jlong pContext, int notUsed, unsigned char* in, jint ofs, jint len) {
+  if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1) {
+    (*ftab->sha1Update)((SHA1_CTX*)pContext, (unsigned char*)(in+ofs), len);
+  } else if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5) {
+    (*ftab->md5Update)((MD5_CTX*)pContext, (unsigned char*)(in+ofs), len);
+  } else { // SHA-2 family
+    (*ftab->sha2Update)((SHA2_CTX*)pContext, (unsigned char*)(in+ofs), len);
+  }
+  return 0;
+}
+
+// Do digest and free the context immediately
+JNIEXPORT jint JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeDigest
+  (jint mech, jlong pContext, int notUsed, unsigned char* out, jint ofs, jint digestLen) {
+
+  if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1) {
+    (*ftab->sha1Final)((unsigned char*)(out + ofs), (SHA1_CTX *)pContext);
+    free((SHA1_CTX *)pContext);
+  } else if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5) {
+    (*ftab->md5Final)((unsigned char*)(out + ofs), (MD5_CTX *)pContext);
+    free((MD5_CTX *)pContext);
+  } else { // SHA-2 family
+    (*ftab->sha2Final)((unsigned char*)(out + ofs), (SHA2_CTX *)pContext);
+    free((SHA2_CTX *)pContext);
+  }
+  return 0;
+}
+
+JNIEXPORT jlong JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeClone
+  (jint mech, jlong pContext) {
+  void *copy = NULL;
+  size_t len = 0;
+
+  if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1) {
+    len = sizeof(SHA1_CTX);
+  } else if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5) {
+    len = sizeof(MD5_CTX);
+  } else { // SHA-2 family
+    len = sizeof(SHA2_CTX);
+  }
+  copy = malloc(len);
+  if (copy != NULL) {
+    bcopy((void *)pContext, copy, len);
+  }
+  return (jlong) copy;
+}
+
+JNIEXPORT void JNICALL
+JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeFree
+  (jint mech, jlong pContext) {
+  if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_SHA1) {
+    free((SHA1_CTX*) pContext);
+  } else if (mech == com_oracle_security_ucrypto_NativeDigestMD_MECH_MD5) {
+    free((MD5_CTX*) pContext);
+  } else { // SHA-2 family
+    free((SHA2_CTX*) pContext);
+  }
+}
+
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigestMD
+ * Method:    nativeInit
+ * Signature: (I)J
+ */
+JNIEXPORT jlong JNICALL Java_com_oracle_security_ucrypto_NativeDigestMD_nativeInit
+  (JNIEnv *env, jclass jcls, jint mech) {
+  jlong result = JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeInit(mech);
+  if (result == NULL) {
+     throwOutOfMemoryError(env, NULL);
+  }
+  return result;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigestMD
+ * Method:    nativeUpdate
+ * Signature: (IJ[BII)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeDigestMD_nativeUpdate
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext, jbyteArray jIn, jint jOfs, jint jLen) {
+  unsigned char *bufIn;
+
+  bufIn = (unsigned char *) getBytes(env, jIn, jOfs, jLen);
+  if (!(*env)->ExceptionCheck(env)) {
+    JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeUpdate(mech, pContext, jLen, bufIn, 0, jLen);
+    free(bufIn);
+  }
+  return 0;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigestMD
+ * Method:    nativeDigest
+ * Signature: (IJ[BII)I
+ */
+JNIEXPORT jint JNICALL Java_com_oracle_security_ucrypto_NativeDigestMD_nativeDigest
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext, jbyteArray jOut, jint jOutOfs, jint digestLen) {
+  unsigned char *bufOut;
+
+  bufOut = (unsigned char *) malloc(digestLen);
+  if (bufOut == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return 0;
+  }
+
+  JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeDigest(mech, pContext, digestLen, bufOut, 0, digestLen);
+
+  (*env)->SetByteArrayRegion(env, jOut, jOutOfs, digestLen, (jbyte *) bufOut);
+  free(bufOut);
+  return 0;
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigestMD
+ * Method:    nativeClone
+ * Signature: (IJ)J
+ */
+JNIEXPORT jlong JNICALL Java_com_oracle_security_ucrypto_NativeDigestMD_nativeClone
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext) {
+  return JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeClone(mech, pContext);
+}
+
+/*
+ * Class:     com_oracle_security_ucrypto_NativeDigestMD
+ * Method:    nativeFree
+ * Signature: (IJ)V
+ */
+JNIEXPORT void JNICALL Java_com_oracle_security_ucrypto_NativeDigestMD_nativeFree
+  (JNIEnv *env, jclass jcls, jint mech, jlong pContext) {
+  JavaCritical_com_oracle_security_ucrypto_NativeDigestMD_nativeFree(mech, pContext);
+}
+
diff -ur -N /tmp/a/solaris/native/libj2ucrypto/nativeFunc.c jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeFunc.c
--- /tmp/a/solaris/native/libj2ucrypto/nativeFunc.c	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeFunc.c	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <link.h>
+#include "nativeFunc.h"
+
+/* standard md5/md/softcrypto method names (ordering is from mapfile) */
+static const char MD5_INIT[]                     = "MD5Init";
+static const char MD5_UPDATE[]                   = "MD5Update";
+static const char MD5_FINAL[]                    = "MD5Final";
+static const char SHA1_INIT[]                    = "SHA1Init";
+static const char SHA1_UPDATE[]                  = "SHA1Update";
+static const char SHA1_FINAL[]                   = "SHA1Final";
+static const char SHA2_INIT[]                    = "SHA2Init";
+static const char SHA2_UPDATE[]                  = "SHA2Update";
+static const char SHA2_FINAL[]                   = "SHA2Final";
+static const char UCRYPTO_VERSION[]              = "ucrypto_version";
+static const char UCRYPTO_GET_MECHLIST[]         = "ucrypto_get_mechlist";
+
+static const char UCRYPTO_ENCRYPT_INIT[]         = "ucrypto_encrypt_init";
+static const char UCRYPTO_ENCRYPT_UPDATE[]       = "ucrypto_encrypt_update";
+static const char UCRYPTO_ENCRYPT_FINAL[]        = "ucrypto_encrypt_final";
+static const char UCRYPTO_ENCRYPT[]              = "ucrypto_encrypt";
+
+static const char UCRYPTO_DECRYPT_INIT[]         = "ucrypto_decrypt_init";
+static const char UCRYPTO_DECRYPT_UPDATE[]       = "ucrypto_decrypt_update";
+static const char UCRYPTO_DECRYPT_FINAL[]        = "ucrypto_decrypt_final";
+static const char UCRYPTO_DECRYPT[]              = "ucrypto_decrypt";
+
+static const char UCRYPTO_SIGN_INIT[]            = "ucrypto_sign_init";
+static const char UCRYPTO_SIGN_UPDATE[]          = "ucrypto_sign_update";
+static const char UCRYPTO_SIGN_FINAL[]           = "ucrypto_sign_final";
+
+static const char UCRYPTO_VERIFY_INIT[]          = "ucrypto_verify_init";
+static const char UCRYPTO_VERIFY_UPDATE[]        = "ucrypto_verify_update";
+static const char UCRYPTO_VERIFY_FINAL[]         = "ucrypto_verify_final";
+
+static const char UCRYPTO_DIGEST_INIT[]          = "ucrypto_digest_init";
+static const char UCRYPTO_DIGEST_UPDATE[]        = "ucrypto_digest_update";
+static const char UCRYPTO_DIGEST_FINAL[]         = "ucrypto_digest_final";
+
+static const char UCRYPTO_FREE_CONTEXT[]         = "ucrypto_free_context";
+
+static const char UCRYPTO_STRERROR[]             = "ucrypto_strerror";
+
+/**
+ * Initialize native T4 crypto function pointers
+ */
+jboolean* loadNative() {
+
+  jboolean* buf;
+  void *lib;
+
+  buf = malloc(2 * sizeof(jboolean));
+  buf[0] = buf[1] = JNI_FALSE;
+  ftab = (T4CRYPTO_FUNCTION_TABLE_PTR) calloc(1, sizeof(T4CRYPTO_FUNCTION_TABLE));
+  if (ftab == NULL) {
+    free(buf);
+    return NULL;
+  }
+
+  lib = dlopen("libsoftcrypto.so", RTLD_NOW);
+  if (lib != NULL) {
+    // These APIs aren't available for v0 lib on Solaris 10
+    ftab->ucryptoVersion = (UCRYPTO_VERSION_FN_PTR)
+      dlsym(lib, UCRYPTO_VERSION);
+    ftab->ucryptoGetMechList = (UCRYPTO_GET_MECHLIST_FN_PTR)
+      dlsym(lib, UCRYPTO_GET_MECHLIST);
+    ftab->ucryptoSignInit = (UCRYPTO_SIGN_INIT_FN_PTR)
+      dlsym(lib, UCRYPTO_SIGN_INIT);
+    ftab->ucryptoSignUpdate = (UCRYPTO_SIGN_UPDATE_FN_PTR)
+      dlsym(lib, UCRYPTO_SIGN_UPDATE);
+    ftab->ucryptoSignFinal = (UCRYPTO_SIGN_FINAL_FN_PTR)
+      dlsym(lib, UCRYPTO_SIGN_FINAL);
+    ftab->ucryptoVerifyInit = (UCRYPTO_VERIFY_INIT_FN_PTR)
+      dlsym(lib, UCRYPTO_VERIFY_INIT);
+    ftab->ucryptoVerifyUpdate = (UCRYPTO_VERIFY_UPDATE_FN_PTR)
+      dlsym(lib, UCRYPTO_VERIFY_UPDATE);
+    ftab->ucryptoVerifyFinal = (UCRYPTO_VERIFY_FINAL_FN_PTR)
+      dlsym(lib, UCRYPTO_VERIFY_FINAL);
+
+    // These APS are added starting S12
+    ftab->ucryptoDigestInit = (UCRYPTO_DIGEST_INIT_FN_PTR)
+      dlsym(lib, UCRYPTO_DIGEST_INIT);
+    ftab->ucryptoDigestUpdate = (UCRYPTO_DIGEST_UPDATE_FN_PTR)
+      dlsym(lib, UCRYPTO_DIGEST_UPDATE);
+    ftab->ucryptoDigestFinal = (UCRYPTO_DIGEST_FINAL_FN_PTR)
+      dlsym(lib, UCRYPTO_DIGEST_FINAL);
+
+    ftab->ucryptoFreeContext = (UCRYPTO_FREE_CONTEXT_FN_PTR)
+      dlsym(lib, UCRYPTO_FREE_CONTEXT);
+
+    ftab->ucryptoStrerror = (UCRYPTO_STRERROR_FN_PTR)
+      dlsym(lib, UCRYPTO_STRERROR);
+
+
+    // These should be avilable for all libsoftcrypto libs
+    ftab->ucryptoEncryptInit = (UCRYPTO_ENCRYPT_INIT_FN_PTR)
+      dlsym(lib, UCRYPTO_ENCRYPT_INIT);
+    ftab->ucryptoEncryptUpdate = (UCRYPTO_ENCRYPT_UPDATE_FN_PTR)
+      dlsym(lib, UCRYPTO_ENCRYPT_UPDATE);
+    ftab->ucryptoEncryptFinal = (UCRYPTO_ENCRYPT_FINAL_FN_PTR)
+      dlsym(lib, UCRYPTO_ENCRYPT_FINAL);
+    ftab->ucryptoEncrypt = (UCRYPTO_ENCRYPT_FN_PTR)
+      dlsym(lib, UCRYPTO_ENCRYPT);
+
+    ftab->ucryptoDecryptInit = (UCRYPTO_DECRYPT_INIT_FN_PTR)
+      dlsym(lib, UCRYPTO_DECRYPT_INIT);
+    ftab->ucryptoDecryptUpdate = (UCRYPTO_DECRYPT_UPDATE_FN_PTR)
+      dlsym(lib, UCRYPTO_DECRYPT_UPDATE);
+    ftab->ucryptoDecryptFinal = (UCRYPTO_DECRYPT_FINAL_FN_PTR)
+      dlsym(lib, UCRYPTO_DECRYPT_FINAL);
+    ftab->ucryptoDecrypt = (UCRYPTO_DECRYPT_FN_PTR)
+      dlsym(lib, UCRYPTO_DECRYPT);
+
+    if (ftab->ucryptoEncryptInit != NULL &&
+        ftab->ucryptoEncryptUpdate != NULL &&
+        ftab->ucryptoEncryptFinal != NULL &&
+        ftab->ucryptoEncrypt != NULL &&
+        ftab->ucryptoDecryptInit != NULL &&
+        ftab->ucryptoDecryptUpdate != NULL &&
+        ftab->ucryptoDecryptFinal != NULL &&
+        ftab->ucryptoDecrypt != NULL) {
+      buf[1] = JNI_TRUE;
+    } else {
+      dlclose(lib);
+    }
+
+    // proceed with libmd when libucrypto does not support digest operations
+    if (ftab->ucryptoDigestInit == NULL ||
+        ftab->ucryptoDigestUpdate == NULL ||
+        ftab->ucryptoDigestFinal == NULL) {
+
+      lib = dlopen("libmd.so", RTLD_NOW);
+      if (lib != NULL) {
+        ftab->md5Init = (MD5INIT_FN_PTR) dlsym(lib, MD5_INIT);
+        ftab->md5Update = (MD5UPDATE_FN_PTR) dlsym(lib, MD5_UPDATE);
+        ftab->md5Final = (MD5FINAL_FN_PTR) dlsym(lib, MD5_FINAL);
+        ftab->sha1Init = (SHA1INIT_FN_PTR) dlsym(lib, SHA1_INIT);
+        ftab->sha1Update = (SHA1UPDATE_FN_PTR) dlsym(lib, SHA1_UPDATE);
+        ftab->sha1Final = (SHA1FINAL_FN_PTR) dlsym(lib, SHA1_FINAL);
+        ftab->sha2Init = (SHA2INIT_FN_PTR) dlsym(lib, SHA2_INIT);
+        ftab->sha2Update = (SHA2UPDATE_FN_PTR) dlsym(lib, SHA2_UPDATE);
+        ftab->sha2Final = (SHA2FINAL_FN_PTR) dlsym(lib, SHA2_FINAL);
+        if (ftab->md5Init != NULL && ftab->md5Update != NULL &&
+            ftab->md5Final != NULL && ftab->sha1Init != NULL &&
+            ftab->sha1Update != NULL && ftab->sha1Final != NULL &&
+            ftab->sha2Init != NULL && ftab->sha2Update != NULL &&
+            ftab->sha2Final != NULL) {
+          buf[0] = JNI_TRUE;
+        } else {
+          dlclose(lib);
+        }
+      }
+    }
+  }
+
+  return buf;
+}
diff -ur -N /tmp/a/solaris/native/libj2ucrypto/nativeFunc.h jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeFunc.h
--- /tmp/a/solaris/native/libj2ucrypto/nativeFunc.h	1970-01-01 01:00:00.000000000 +0100
+++ jdk15-jdk-15-24/src/jdk.crypto.ucrypto/solaris/native/libj2ucrypto/nativeFunc.h	2020-05-20 19:29:11.000000000 +0100
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef SPARCT4_NATIVE_FUNC_H
+#define SPARCT4_NATIVE_FUNC_H
+#include <md5.h>
+#include <sha1.h>
+#include <sha2.h>
+#include <libsoftcrypto.h> // redirects to libucrypto.h starting 11.3
+
+jboolean* loadNative();
+
+/* function pointer definitions */
+
+typedef void (*MD5INIT_FN_PTR)(MD5_CTX *context);
+
+typedef void (*MD5UPDATE_FN_PTR)
+     (MD5_CTX *context, unsigned char *input,
+      unsigned int inlen);
+
+typedef void (*MD5FINAL_FN_PTR)
+     (unsigned char *output, MD5_CTX *context);
+
+typedef void (*SHA1INIT_FN_PTR)(SHA1_CTX *context);
+
+typedef void (*SHA1UPDATE_FN_PTR)
+     (SHA1_CTX *context, unsigned char *input,
+      unsigned int inlen);
+
+typedef void (*SHA1FINAL_FN_PTR)
+     (unsigned char *output, SHA1_CTX *context);
+
+typedef void (*SHA2INIT_FN_PTR)(uint64_t mech, SHA2_CTX *context);
+
+typedef void (*SHA2UPDATE_FN_PTR)
+     (SHA2_CTX *context, unsigned char *input,
+      unsigned int inlen);
+
+typedef void (*SHA2FINAL_FN_PTR)
+     (unsigned char *output, SHA2_CTX *context);
+
+typedef int (*UCRYPTO_VERSION_FN_PTR)();
+
+typedef int (*UCRYPTO_GET_MECHLIST_FN_PTR)(char *str);
+
+typedef int (*UCRYPTO_ENCRYPT_INIT_FN_PTR)
+     (crypto_ctx_t *context, ucrypto_mech_t mech_type,
+      uchar_t *key_str, size_t key_len,
+      void *iv, size_t iv_len);
+typedef int (*UCRYPTO_ENCRYPT_UPDATE_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *in,
+      size_t in_len, uchar_t *out, size_t *out_len);
+typedef int (*UCRYPTO_ENCRYPT_FINAL_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *out,
+      size_t *out_len);
+typedef int (*UCRYPTO_ENCRYPT_FN_PTR)
+     (ucrypto_mech_t mech_type, uchar_t *key_str,
+      size_t key_len, void *iv, size_t iv_len, uchar_t *in,
+      size_t in_len, uchar_t *out, size_t *out_len);
+
+typedef int (*UCRYPTO_DECRYPT_INIT_FN_PTR)
+     (crypto_ctx_t *context,
+      ucrypto_mech_t mech_type, uchar_t *key_str, size_t key_len,
+      void *iv, size_t iv_len);
+typedef int (*UCRYPTO_DECRYPT_UPDATE_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *in,
+      size_t in_len, uchar_t *out, size_t *out_len);
+typedef int (*UCRYPTO_DECRYPT_FINAL_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *out,
+      size_t *out_len);
+typedef int (*UCRYPTO_DECRYPT_FN_PTR)
+     (ucrypto_mech_t mech_type, uchar_t *key_str,
+      size_t key_len, void *iv, size_t iv_len, uchar_t *in,
+      size_t in_len, uchar_t *out, size_t *out_len);
+
+typedef int (*UCRYPTO_SIGN_INIT_FN_PTR)
+     (crypto_ctx_t *context, ucrypto_mech_t mech_type,
+      uchar_t *key_str, size_t key_len,
+      void *iv, size_t iv_len);
+typedef int (*UCRYPTO_SIGN_UPDATE_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *data_str, size_t data_len);
+typedef int (*UCRYPTO_SIGN_FINAL_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *sig_str, size_t *sig_len);
+
+typedef int (*UCRYPTO_VERIFY_INIT_FN_PTR)
+     (crypto_ctx_t *context, ucrypto_mech_t mech_type,
+      uchar_t *key_str, size_t key_len,
+      void *iv, size_t iv_len);
+typedef int (*UCRYPTO_VERIFY_UPDATE_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *data_str, size_t data_len);
+typedef int (*UCRYPTO_VERIFY_FINAL_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *sig_str, size_t *sig_len);
+
+typedef int (*UCRYPTO_DIGEST_INIT_FN_PTR)
+     (crypto_ctx_t *context, ucrypto_mech_t mech_type,
+      void *param, size_t param_len);
+typedef int (*UCRYPTO_DIGEST_UPDATE_FN_PTR)
+     (crypto_ctx_t *context, const uchar_t *data, size_t data_len);
+typedef int (*UCRYPTO_DIGEST_FINAL_FN_PTR)
+     (crypto_ctx_t *context, uchar_t *digest, size_t *digest_len);
+
+typedef void (*UCRYPTO_FREE_CONTEXT_FN_PTR)
+     (crypto_ctx_t *context);
+
+typedef char* (*UCRYPTO_STRERROR_FN_PTR)(int rv);
+
+
+
+/* dynamically resolved functions from libmd, and libsoftcrypto
+   libraries */
+typedef struct T4CRYPTO_FUNCTION_TABLE {
+  MD5INIT_FN_PTR                 md5Init;
+  MD5UPDATE_FN_PTR               md5Update;
+  MD5FINAL_FN_PTR                md5Final;
+  SHA1INIT_FN_PTR                sha1Init;
+  SHA1UPDATE_FN_PTR              sha1Update;
+  SHA1FINAL_FN_PTR               sha1Final;
+  SHA2INIT_FN_PTR                sha2Init;
+  SHA2UPDATE_FN_PTR              sha2Update;
+  SHA2FINAL_FN_PTR               sha2Final;
+  UCRYPTO_VERSION_FN_PTR         ucryptoVersion;
+  UCRYPTO_GET_MECHLIST_FN_PTR    ucryptoGetMechList;
+  UCRYPTO_ENCRYPT_INIT_FN_PTR    ucryptoEncryptInit;
+  UCRYPTO_ENCRYPT_UPDATE_FN_PTR  ucryptoEncryptUpdate;
+  UCRYPTO_ENCRYPT_FINAL_FN_PTR   ucryptoEncryptFinal;
+  UCRYPTO_ENCRYPT_FN_PTR         ucryptoEncrypt;
+  UCRYPTO_DECRYPT_INIT_FN_PTR    ucryptoDecryptInit;
+  UCRYPTO_DECRYPT_UPDATE_FN_PTR  ucryptoDecryptUpdate;
+  UCRYPTO_DECRYPT_FINAL_FN_PTR   ucryptoDecryptFinal;
+  UCRYPTO_DECRYPT_FN_PTR         ucryptoDecrypt;
+  UCRYPTO_SIGN_INIT_FN_PTR       ucryptoSignInit;
+  UCRYPTO_SIGN_UPDATE_FN_PTR     ucryptoSignUpdate;
+  UCRYPTO_SIGN_FINAL_FN_PTR      ucryptoSignFinal;
+  UCRYPTO_VERIFY_INIT_FN_PTR     ucryptoVerifyInit;
+  UCRYPTO_VERIFY_UPDATE_FN_PTR   ucryptoVerifyUpdate;
+  UCRYPTO_VERIFY_FINAL_FN_PTR    ucryptoVerifyFinal;
+  UCRYPTO_DIGEST_INIT_FN_PTR     ucryptoDigestInit;
+  UCRYPTO_DIGEST_UPDATE_FN_PTR   ucryptoDigestUpdate;
+  UCRYPTO_DIGEST_FINAL_FN_PTR    ucryptoDigestFinal;
+  UCRYPTO_FREE_CONTEXT_FN_PTR    ucryptoFreeContext;
+  UCRYPTO_STRERROR_FN_PTR        ucryptoStrerror;
+} T4CRYPTO_FUNCTION_TABLE;
+
+typedef T4CRYPTO_FUNCTION_TABLE *T4CRYPTO_FUNCTION_TABLE_PTR;
+
+/* global function table */
+T4CRYPTO_FUNCTION_TABLE_PTR ftab;
+
+#endif
--- a/make/ZipSecurity.gmk	Tue Jan  9 21:18:15 2024
+++ b/make/ZipSecurity.gmk	Wed May 20 19:29:11 2020
@@ -45,6 +45,7 @@
         modules/jdk.crypto.mscapi/sun/security/mscapi \
         modules/jdk.crypto.cryptoki/sun/security/pkcs11 \
         modules/jdk.crypto.cryptoki/sun/security/pkcs11/wrapper \
+        modules/jdk.crypto.ucrypto/com/oracle/security/ucrypto \
         modules/java.base/javax/net \
         modules/java.base/javax/security/cert \
         modules/java.base/com/sun/net/ssl \
--- a/make/conf/module-loader-map.conf~	Tue Jan  9 21:18:15 2024
+++ b/make/conf/module-loader-map.conf	Mon Apr  8 13:50:32 2024
@@ -93,3 +93,7 @@
 PLATFORM_MODULES_windows= \
     jdk.crypto.mscapi \
     #
+
+PLATFORM_MODULES_solaris= \
+    jdk.crypto.ucrypto \
+    #
